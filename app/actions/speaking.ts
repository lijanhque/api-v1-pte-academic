'use server'

import { auth } from '@/lib/auth/auth'
import { db } from '@/lib/db/drizzle'
import { speakingAttempts } from '@/lib/db/schema'
import { scoreAttempt } from '@/lib/pte/speaking-score'
import type { SpeakingType, SpeakingTimings } from '@/lib/pte/types'
import type { SpeakingAttempt } from '@/lib/db/schema'
import { upload } from '@vercel/blob'
import { and, eq } from 'drizzle-orm'
import { z } from 'zod'
import { headers } from 'next/headers'

const submitSpeakingAttemptSchema = z.object({
  questionId: z.string().uuid(),
  type: z.string(),
  timings: z.string().optional(),
  audio: z.instanceof(File),
})

export async function submitSpeakingAttempt(
  formData: FormData
): Promise<SpeakingAttempt> {
  const session = await auth.api.getSession({
    headers: await headers(),
  })
  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }
  const userId = session.user.id

  const raw = Object.fromEntries(formData.entries())
  const { questionId, type, timings, audio } =
    submitSpeakingAttemptSchema.parse(raw)

  // 1. Upload audio using the existing upload logic
  const file = new File(
    [audio],
    `speaking-${type}-${questionId}-${userId}-${Date.now()}.webm`,
    { type: audio.type }
  )

  const { blobUrl, pathname } = await (async () => {
    // Try to use the existing uploadAudioWithFallback logic
    try {
      // First try to get a presigned URL
      const presignRes = await fetch('/api/uploads/audio', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ type, questionId, ext: 'webm' }),
      })

      if (presignRes.ok) {
        const { uploadUrl, blobUrl, pathname } = await presignRes.json()

        // Upload directly to presigned URL
        const fd = new FormData()
        fd.append('file', file)
        const uploadRes = await fetch(uploadUrl, {
          method: 'POST',
          body: fd,
        })

        if (uploadRes.ok) {
          return { blobUrl, pathname }
        }
      }
    } catch {
      // Fall through to server upload
    }

    // Fallback to server upload
    const fd = new FormData()
    fd.append('file', file)
    fd.append('type', type)
    fd.append('questionId', questionId)
    fd.append('ext', 'webm')

    const uploadRes = await fetch('/api/uploads/audio', {
      method: 'POST',
      body: fd,
    })

    if (!uploadRes.ok) {
      throw new Error('Audio upload failed')
    }

    const result = await uploadRes.json()
    return { blobUrl: result.blobUrl, pathname: result.pathname }
  })()

  // 2. Score attempt
  const durationMs = audio.size ? audio.size / 16 : 0 // Rough estimate
  const score = await scoreAttempt({
    type: type as SpeakingType,
    question: { id: questionId, type: type as SpeakingType, title: '', promptText: '' }, // Minimal question data
    transcript: '', // Will be generated by scoring
    audioUrl: blobUrl,
    durationMs,
  })

  // 3. Save to DB
  const scoresJson = {
    content: score.content,
    pronunciation: score.pronunciation,
    fluency: score.fluency,
    total: score.total,
    rubric: score.rubric,
    feedback: score.feedback,
    meta: score.meta || {},
  }

  const [attempt] = await db
    .insert(speakingAttempts)
    .values({
      userId,
      questionId,
      type: type as SpeakingType,
      audioUrl: blobUrl,
      transcript: '', // Will be populated by scoring
      scores: scoresJson as any,
      durationMs,
      wordsPerMinute: '0',
      fillerRate: '0',
      timings: timings ? JSON.parse(timings) : {},
    })
    .returning()

  return attempt as SpeakingAttempt
}

export async function getSpeakingAttempts(
  questionId: string
): Promise<SpeakingAttempt[]> {
  const session = await auth.api.getSession({
    headers: await headers(),
  })
  if (!session?.user?.id) {
    return []
  }
  const userId = session.user.id

  return db
    .select()
    .from(speakingAttempts)
    .where(
      and(
        eq(speakingAttempts.userId, userId),
        eq(speakingAttempts.questionId, questionId)
      )
    )
    .orderBy(speakingAttempts.createdAt)
}