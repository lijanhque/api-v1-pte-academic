"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisStateAdapter = void 0;
const redis_1 = require("redis");
function isRedisClient(input) {
    return typeof input === 'object' && 'isOpen' in input && 'connect' in input;
}
class RedisStateAdapter {
    constructor(redisConnection, options) {
        this.connected = false;
        this.keyPrefix = options?.keyPrefix || 'motia:state:';
        this.ttl = options?.ttl;
        if (isRedisClient(redisConnection)) {
            this.client = redisConnection;
            this.isExternalClient = true;
            this.connected = this.client.isOpen;
        }
        else {
            const config = redisConnection;
            this.isExternalClient = false;
            this.client = (0, redis_1.createClient)(config);
            this.client.on('error', (err) => {
                console.error('[Redis State] Client error:', err);
            });
            this.client.on('connect', () => {
                this.connected = true;
            });
            this.client.on('disconnect', () => {
                console.warn('[Redis State] Disconnected');
                this.connected = false;
            });
            this.client.on('reconnecting', () => {
                console.log('[Redis State] Reconnecting...');
            });
            this.connect();
        }
    }
    async connect() {
        if (!this.connected && !this.client.isOpen) {
            try {
                await this.client.connect();
            }
            catch (error) {
                console.error('[Redis State] Failed to connect:', error);
                throw error;
            }
        }
    }
    async ensureConnected() {
        if (!this.client.isOpen) {
            await this.connect();
        }
    }
    makeKey(traceId, key) {
        return `${this.keyPrefix}${traceId}:${key}`;
    }
    makeTracePrefix(traceId) {
        return `${this.keyPrefix}${traceId}:`;
    }
    extractKey(fullKey, traceId) {
        const prefix = this.makeTracePrefix(traceId);
        return fullKey.slice(prefix.length);
    }
    determineType(value) {
        if (value === null)
            return 'null';
        if (Array.isArray(value))
            return 'array';
        return (['string', 'number', 'boolean', 'object'].find((type) => typeof value === type) || 'object');
    }
    async get(traceId, key) {
        await this.ensureConnected();
        const fullKey = this.makeKey(traceId, key);
        const value = await this.client.get(fullKey);
        return value ? JSON.parse(value) : null;
    }
    async set(traceId, key, value) {
        await this.ensureConnected();
        const fullKey = this.makeKey(traceId, key);
        const serialized = JSON.stringify(value);
        if (this.ttl) {
            await this.client.setEx(fullKey, this.ttl, serialized);
        }
        else {
            await this.client.set(fullKey, serialized);
        }
        return value;
    }
    async delete(traceId, key) {
        await this.ensureConnected();
        const fullKey = this.makeKey(traceId, key);
        const value = await this.get(traceId, key);
        await this.client.del(fullKey);
        return value;
    }
    async getGroup(traceId) {
        await this.ensureConnected();
        const pattern = `${this.makeTracePrefix(traceId)}*`;
        const keys = await this.scanKeys(pattern);
        if (keys.length === 0)
            return [];
        const values = await this.client.mGet(keys);
        return values.filter((v) => v !== null).map((v) => JSON.parse(v));
    }
    async clear(traceId) {
        await this.ensureConnected();
        const pattern = `${this.makeTracePrefix(traceId)}*`;
        const keys = await this.scanKeys(pattern);
        if (keys.length > 0) {
            await this.client.del(keys);
        }
    }
    async cleanup() {
        if (!this.isExternalClient && this.client.isOpen) {
            await this.client.quit();
        }
    }
    async keys(traceId) {
        await this.ensureConnected();
        const pattern = `${this.makeTracePrefix(traceId)}*`;
        const keys = await this.scanKeys(pattern);
        return keys.map((key) => this.extractKey(key, traceId));
    }
    async traceIds() {
        await this.ensureConnected();
        const pattern = `${this.keyPrefix}*`;
        const keys = await this.scanKeys(pattern);
        const traceIdSet = new Set();
        for (const key of keys) {
            const withoutPrefix = key.slice(this.keyPrefix.length);
            const traceId = withoutPrefix.split(':')[0];
            if (traceId) {
                traceIdSet.add(traceId);
            }
        }
        return Array.from(traceIdSet);
    }
    async items(input) {
        await this.ensureConnected();
        const items = [];
        if (input.groupId) {
            const pattern = `${this.makeTracePrefix(input.groupId)}*`;
            const keys = await this.scanKeys(pattern);
            for (const fullKey of keys) {
                const value = await this.client.get(fullKey);
                if (value !== null) {
                    const key = this.extractKey(fullKey, input.groupId);
                    const parsedValue = JSON.parse(value);
                    items.push({
                        groupId: input.groupId,
                        key,
                        type: this.determineType(parsedValue),
                        value: parsedValue,
                    });
                }
            }
        }
        else {
            const traceIds = await this.traceIds();
            for (const traceId of traceIds) {
                const pattern = `${this.makeTracePrefix(traceId)}*`;
                const keys = await this.scanKeys(pattern);
                for (const fullKey of keys) {
                    const value = await this.client.get(fullKey);
                    if (value !== null) {
                        const key = this.extractKey(fullKey, traceId);
                        const parsedValue = JSON.parse(value);
                        items.push({
                            groupId: traceId,
                            key,
                            type: this.determineType(parsedValue),
                            value: parsedValue,
                        });
                    }
                }
            }
        }
        if (input.filter && input.filter.length > 0) {
            return this.applyFilters(items, input.filter);
        }
        return items;
    }
    async scanKeys(pattern) {
        const keys = [];
        let cursor = '0';
        do {
            const result = await this.client.scan(cursor.toString(), {
                MATCH: pattern,
                COUNT: 100,
            });
            cursor = result.cursor;
            keys.push(...result.keys);
        } while (String(cursor) !== '0');
        return keys;
    }
    applyFilters(items, filters) {
        return items.filter((item) => {
            return filters.every((filter) => this.matchesFilter(item, filter));
        });
    }
    matchesFilter(item, filter) {
        const value = typeof item.value === 'object' && item.value !== null ? item.value[filter.valueKey] : item.value;
        const filterValue = filter.value;
        switch (filter.operation) {
            case 'eq':
                return value === filterValue;
            case 'neq':
                return value !== filterValue;
            case 'gt':
                return value > filterValue;
            case 'gte':
                return value >= filterValue;
            case 'lt':
                return value < filterValue;
            case 'lte':
                return value <= filterValue;
            case 'contains':
                return typeof value === 'string' && value.includes(filterValue);
            case 'notContains':
                return typeof value === 'string' && !value.includes(filterValue);
            case 'startsWith':
                return typeof value === 'string' && value.startsWith(filterValue);
            case 'endsWith':
                return typeof value === 'string' && value.endsWith(filterValue);
            case 'isNotNull':
                return value !== null && value !== undefined;
            case 'isNull':
                return value === null || value === undefined;
            default:
                return false;
        }
    }
}
exports.RedisStateAdapter = RedisStateAdapter;
