"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisStreamAdapter = void 0;
const core_1 = require("@motiadev/core");
const redis_1 = require("redis");
class RedisStreamAdapter extends core_1.StreamAdapter {
    constructor(streamName, config, sharedClient) {
        super(streamName);
        this.subscriptions = new Map();
        this.keyPrefix = config.keyPrefix || 'motia:stream:';
        this.groupPrefix = `${this.keyPrefix}${streamName}:group:`;
        this.client = sharedClient;
    }
    makeGroupKey(groupId) {
        return `${this.groupPrefix}${groupId}`;
    }
    makeChannelKey(channel) {
        return channel.id
            ? `motia:stream:events:${this.streamName}:${channel.groupId}:${channel.id}`
            : `motia:stream:events:${this.streamName}:${channel.groupId}`;
    }
    async get(groupId, id) {
        const hashKey = this.makeGroupKey(groupId);
        const value = await this.client.hGet(hashKey, id);
        return value ? JSON.parse(value) : null;
    }
    async set(groupId, id, data) {
        const hashKey = this.makeGroupKey(groupId);
        const dataWithTimestamp = data;
        const item = {
            ...data,
            id,
            _createdAt: dataWithTimestamp._createdAt || Date.now(),
        };
        const itemJson = JSON.stringify(item);
        const existed = await this.client.hExists(hashKey, id);
        const eventType = existed ? 'update' : 'create';
        await Promise.all([
            this.client.hSet(hashKey, id, itemJson),
            this.send({ groupId, id }, { type: eventType, data: item }),
        ]);
        return item;
    }
    async delete(groupId, id) {
        const hashKey = this.makeGroupKey(groupId);
        const value = await this.client.hGet(hashKey, id);
        if (!value)
            return null;
        const item = JSON.parse(value);
        await Promise.all([this.client.hDel(hashKey, id), this.send({ groupId, id }, { type: 'delete', data: item })]);
        return item;
    }
    async getGroup(groupId) {
        const hashKey = this.makeGroupKey(groupId);
        const values = await this.client.hGetAll(hashKey);
        const items = Object.values(values).map((v) => JSON.parse(v));
        return items.sort((a, b) => {
            const aTime = a._createdAt || 0;
            const bTime = b._createdAt || 0;
            return aTime - bTime;
        });
    }
    async send(channel, event) {
        const channelKey = this.makeChannelKey(channel);
        await this.client.publish(channelKey, JSON.stringify(event));
    }
    async subscribe(channel, handler) {
        const channelKey = this.makeChannelKey(channel);
        if (!this.subClient) {
            const socketConfig = this.client.options?.socket;
            const keepAliveValue = socketConfig?.keepAlive;
            const clientConfig = {
                socket: {
                    host: socketConfig?.host || 'localhost',
                    port: socketConfig?.port || 6379,
                    keepAlive: keepAliveValue,
                    noDelay: true,
                },
                password: this.client.options?.password,
                username: this.client.options?.username,
                database: this.client.options?.database || 0,
            };
            this.subClient = (0, redis_1.createClient)(clientConfig);
            this.subClient.on('error', (err) => {
                console.error('[Redis Stream] Sub client error:', err);
            });
            await this.subClient.connect();
        }
        this.subscriptions.set(channelKey, handler);
        const subClient = this.subClient;
        if (!subClient)
            return;
        await subClient.subscribe(channelKey, async (message) => {
            try {
                const event = JSON.parse(message);
                await handler(event);
            }
            catch (error) {
                console.error('[Redis Stream] Error processing subscription message:', error);
            }
        });
    }
    async unsubscribe(channel) {
        if (!this.subClient)
            return;
        const channelKey = this.makeChannelKey(channel);
        this.subscriptions.delete(channelKey);
        try {
            await this.subClient.unsubscribe(channelKey);
        }
        catch (error) {
            console.error('[Redis Stream] Error unsubscribing:', error);
        }
    }
    async clear(groupId) {
        const hashKey = this.makeGroupKey(groupId);
        await this.client.del(hashKey);
    }
    async query(groupId, filter) {
        let items = await this.getGroup(groupId);
        if (filter.where) {
            const where = filter.where;
            items = items.filter((item) => {
                return Object.entries(where).every(([key, value]) => {
                    const itemKey = key;
                    return item[itemKey] === value;
                });
            });
        }
        if (filter.orderBy) {
            items.sort((a, b) => {
                const orderKey = filter.orderBy;
                const aVal = a[orderKey];
                const bVal = b[orderKey];
                const comparison = aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                return filter.orderDirection === 'desc' ? -comparison : comparison;
            });
        }
        if (filter.offset) {
            items = items.slice(filter.offset);
        }
        if (filter.limit) {
            items = items.slice(0, filter.limit);
        }
        return items;
    }
    async cleanup() {
        this.subscriptions.clear();
    }
}
exports.RedisStreamAdapter = RedisStreamAdapter;
