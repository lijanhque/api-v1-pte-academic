"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.callStepFile = void 0;
const path_1 = __importDefault(require("path"));
const utils_1 = require("./analytics/utils");
const process_manager_1 = require("./process-communication/process-manager");
const utils_2 = require("./utils");
const getLanguageBasedRunner = (stepFilePath = '') => {
    const isPython = stepFilePath.endsWith('.py');
    const isRuby = stepFilePath.endsWith('.rb');
    const isNode = stepFilePath.endsWith('.js') || stepFilePath.endsWith('.ts');
    if (isPython) {
        const pythonRunner = path_1.default.join(__dirname, 'python', 'python-runner.py');
        return { runner: pythonRunner, command: 'python', args: [] };
    }
    else if (isRuby) {
        const rubyRunner = path_1.default.join(__dirname, 'ruby', 'ruby-runner.rb');
        return { runner: rubyRunner, command: 'ruby', args: [] };
    }
    else if (isNode) {
        if (process.env._MOTIA_TEST_MODE === 'true') {
            const nodeRunner = path_1.default.join(__dirname, 'node', 'node-runner.ts');
            return { runner: nodeRunner, command: 'node', args: ['-r', 'ts-node/register'] };
        }
        const nodeRunner = path_1.default.join(__dirname, 'node', 'node-runner.js');
        return { runner: nodeRunner, command: 'node', args: [] };
    }
    throw Error(`Unsupported file extension ${stepFilePath}`);
};
const callStepFile = (options, motia) => {
    const { step, traceId, data, tracer, logger, contextInFirstArg = false, infrastructure } = options;
    const flows = step.config.flows;
    return new Promise((resolve, reject) => {
        const streamConfig = motia.lockedData.getStreams();
        const streams = Object.keys(streamConfig).map((name) => ({ name }));
        const jsonData = JSON.stringify({ data, flows, traceId, contextInFirstArg, streams });
        const { runner, command, args } = getLanguageBasedRunner(step.filePath);
        let result;
        let timeoutId;
        const processManager = new process_manager_1.ProcessManager({
            command,
            args: [...args, runner, step.filePath, jsonData],
            logger,
            context: 'StepExecution',
            projectRoot: motia.lockedData.baseDir,
        });
        (0, utils_1.trackEvent)('step_execution_started', {
            stepName: step.config.name,
            language: command,
            type: step.config.type,
            streams: streams.length,
        });
        const timeoutSeconds = infrastructure?.handler?.timeout;
        if (timeoutSeconds) {
            timeoutId = setTimeout(() => {
                processManager.kill();
                const errorMessage = `Step execution timed out after ${timeoutSeconds} seconds`;
                logger.error(errorMessage, { step: step.config.name, timeout: timeoutSeconds });
                tracer.end({ message: errorMessage });
                (0, utils_1.trackEvent)('step_execution_timeout', {
                    stepName: step.config.name,
                    traceId,
                    timeout: timeoutSeconds,
                });
                reject(new Error(errorMessage));
            }, timeoutSeconds * 1000);
        }
        processManager
            .spawn()
            .then(() => {
            processManager.handler('close', async (err) => {
                processManager.kill();
                if (err) {
                    (0, utils_1.trackEvent)('step_execution_error', {
                        stepName: step.config.name,
                        traceId,
                        message: err.message,
                    });
                    tracer.end({
                        message: err.message,
                        code: err.code,
                        stack: err.stack?.replace(new RegExp(`${motia.lockedData.baseDir}/`), ''),
                    });
                    reject(new Error(err.message || 'Handler execution failed'));
                }
                else {
                    tracer.end();
                }
            });
            processManager.handler('log', async (input) => logger.log(input));
            processManager.handler('state.get', async (input) => {
                tracer.stateOperation('get', input);
                return motia.state.get(input.traceId, input.key);
            });
            processManager.handler('state.set', async (input) => {
                tracer.stateOperation('set', { traceId: input.traceId, key: input.key, value: input.value });
                return motia.state.set(input.traceId, input.key, input.value);
            });
            processManager.handler('state.delete', async (input) => {
                tracer.stateOperation('delete', input);
                return motia.state.delete(input.traceId, input.key);
            });
            processManager.handler('state.clear', async (input) => {
                tracer.stateOperation('clear', input);
                return motia.state.clear(input.traceId);
            });
            processManager.handler(`state.getGroup`, (input) => {
                tracer.stateOperation('getGroup', input);
                return motia.state.getGroup(input.groupId);
            });
            processManager.handler('result', async (input) => {
                const anyInput = { ...input };
                if (anyInput.body && anyInput.body.type === 'Buffer') {
                    anyInput.body = Buffer.from(anyInput.body.data);
                }
                result = anyInput;
            });
            processManager.handler('emit', async (input) => {
                const flows = step.config.flows;
                if (!(0, utils_2.isAllowedToEmit)(step, input.topic)) {
                    tracer.emitOperation(input.topic, input.data, false);
                    return motia.printer.printInvalidEmit(step, input.topic);
                }
                tracer.emitOperation(input.topic, input.data, true);
                return motia.eventAdapter.emit({ ...input, traceId, flows, logger, tracer });
            });
            Object.entries(streamConfig).forEach(([name, streamFactory]) => {
                const stateStream = streamFactory();
                processManager.handler(`streams.${name}.get`, async (input) => {
                    tracer.streamOperation(name, 'get', input);
                    return stateStream.get(input.groupId, input.id);
                });
                processManager.handler(`streams.${name}.set`, async (input) => {
                    tracer.streamOperation(name, 'set', { groupId: input.groupId, id: input.id, data: input.data });
                    return stateStream.set(input.groupId, input.id, input.data);
                });
                processManager.handler(`streams.${name}.delete`, async (input) => {
                    tracer.streamOperation(name, 'delete', input);
                    return stateStream.delete(input.groupId, input.id);
                });
                processManager.handler(`streams.${name}.getGroup`, async (input) => {
                    tracer.streamOperation(name, 'getGroup', input);
                    return stateStream.getGroup(input.groupId);
                });
                processManager.handler(`streams.${name}.send`, async (input) => {
                    tracer.streamOperation(name, 'send', input);
                    return stateStream.send(input.channel, input.event);
                });
            });
            processManager.onStdout((data) => {
                try {
                    const message = JSON.parse(data.toString());
                    logger.log(message);
                }
                catch {
                    logger.info(Buffer.from(data).toString());
                }
            });
            processManager.onStderr((data) => logger.error(Buffer.from(data).toString()));
            processManager.onProcessClose((code) => {
                if (timeoutId)
                    clearTimeout(timeoutId);
                processManager.close();
                if (code !== 0 && code !== null) {
                    const error = { message: `Process exited with code ${code}`, code };
                    tracer.end(error);
                    (0, utils_1.trackEvent)('step_execution_error', { stepName: step.config.name, traceId, code });
                    reject(`Process exited with code ${code}`);
                }
                else {
                    tracer.end();
                    resolve(result);
                }
            });
            processManager.onProcessError((error) => {
                if (timeoutId)
                    clearTimeout(timeoutId);
                processManager.close();
                tracer.end({
                    message: error.message,
                    code: error.code,
                    stack: error.stack,
                });
                if (error.code === 'ENOENT') {
                    (0, utils_1.trackEvent)('step_execution_error', {
                        stepName: step.config.name,
                        traceId,
                        code: error.code,
                        message: error.message,
                    });
                    reject(`Executable ${command} not found`);
                }
                else {
                    reject(error);
                }
            });
        })
            .catch((error) => {
            if (timeoutId)
                clearTimeout(timeoutId);
            tracer.end({
                message: error.message,
                code: error.code,
                stack: error.stack,
            });
            (0, utils_1.trackEvent)('step_execution_error', {
                stepName: step.config.name,
                traceId,
                code: error.code,
                message: error.message,
            });
            reject(`Failed to spawn process: ${error}`);
        });
    });
};
exports.callStepFile = callStepFile;
