"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryQueueEventAdapter = void 0;
const uuid_1 = require("uuid");
const defaults_1 = require("../../../infrastructure-validator/defaults");
const queue_manager_1 = require("../../../queue-manager");
class InMemoryQueueEventAdapter {
    constructor() {
        this.queueManager = new queue_manager_1.QueueManager();
        this.subscriptions = new Map();
    }
    async emit(event) {
        await this.queueManager.enqueue(event.topic, event, event.messageGroupId);
    }
    async subscribe(topic, stepName, handler, queueConfig) {
        const id = (0, uuid_1.v4)();
        this.subscriptions.set(id, { topic, handler: handler });
        const config = queueConfig || defaults_1.DEFAULT_QUEUE_CONFIG;
        this.queueManager.subscribe(topic, handler, config, id);
        const handle = {
            topic,
            id,
            unsubscribe: async () => {
                await this.unsubscribe(handle);
            },
        };
        return handle;
    }
    async unsubscribe(handle) {
        const subscription = this.subscriptions.get(handle.id);
        if (subscription) {
            this.queueManager.unsubscribe(handle.topic, subscription.handler);
            this.subscriptions.delete(handle.id);
        }
    }
    async shutdown() {
        this.subscriptions.clear();
    }
    async getSubscriptionCount(topic) {
        return Array.from(this.subscriptions.values()).filter((sub) => sub.topic === topic).length;
    }
    async listTopics() {
        return Array.from(new Set(Array.from(this.subscriptions.values()).map((sub) => sub.topic)));
    }
    getAllMetrics() {
        return this.queueManager.getAllMetrics();
    }
}
exports.InMemoryQueueEventAdapter = InMemoryQueueEventAdapter;
