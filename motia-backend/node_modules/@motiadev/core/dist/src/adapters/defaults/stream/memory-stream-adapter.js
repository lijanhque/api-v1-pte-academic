"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryStreamAdapter = void 0;
const stream_adapter_interface_1 = require("../../interfaces/stream-adapter.interface");
class MemoryStreamAdapter extends stream_adapter_interface_1.StreamAdapter {
    constructor(streamName) {
        super(streamName);
        this.state = {};
    }
    async init() {
        this.state = {};
    }
    async getGroup(groupId) {
        const prefix = this._makeKeyPrefix(groupId);
        return Object.entries(this.state)
            .filter(([key]) => key.startsWith(prefix))
            .map(([key, value]) => {
            const id = key.split(':').pop();
            return { ...value, id };
        });
    }
    async get(groupId, id) {
        const key = this._makeKey(groupId, id);
        const value = this.state[key];
        return value ? { ...value, id } : null;
    }
    async set(groupId, id, value) {
        const key = this._makeKey(groupId, id);
        this.state[key] = value;
        return { ...value, id };
    }
    async delete(groupId, id) {
        const key = this._makeKey(groupId, id);
        const value = await this.get(groupId, id);
        if (value) {
            delete this.state[key];
        }
        return value;
    }
    async clear(groupId) {
        const prefix = this._makeKeyPrefix(groupId);
        for (const key in this.state) {
            if (key.startsWith(prefix)) {
                delete this.state[key];
            }
        }
    }
    _makeKeyPrefix(groupId) {
        return `${this.streamName}:${groupId}`;
    }
    _makeKey(groupId, id) {
        return `${this.streamName}:${groupId}:${id}`;
    }
}
exports.MemoryStreamAdapter = MemoryStreamAdapter;
