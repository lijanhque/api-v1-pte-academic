"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryStateAdapter = void 0;
const utils_1 = require("./utils");
class MemoryStateAdapter {
    constructor() {
        this.state = {};
        this.state = {};
    }
    async getGroup(groupId) {
        return Object.entries(this.state)
            .filter(([key]) => key.startsWith(groupId))
            .map(([, value]) => value);
    }
    async get(traceId, key) {
        const fullKey = this._makeKey(traceId, key);
        return this.state[fullKey] ? this.state[fullKey] : null;
    }
    async set(traceId, key, value) {
        const fullKey = this._makeKey(traceId, key);
        this.state[fullKey] = value;
        return value;
    }
    async delete(traceId, key) {
        const fullKey = this._makeKey(traceId, key);
        const value = await this.get(traceId, key);
        if (value) {
            delete this.state[fullKey];
        }
        return value;
    }
    async clear(traceId) {
        const pattern = this._makeKey(traceId, '');
        for (const key in this.state) {
            if (key.startsWith(pattern)) {
                delete this.state[key];
            }
        }
    }
    async keys(traceId) {
        return Object.keys(this.state)
            .filter((key) => key.startsWith(this._makeKey(traceId, '')))
            .map((key) => key.replace(this._makeKey(traceId, ''), ''));
    }
    async traceIds() {
        const traceIds = new Set();
        Object.keys(this.state).forEach((key) => traceIds.add(key.split(':')[0]));
        return Array.from(traceIds);
    }
    async items(input) {
        return Object.entries(this.state)
            .map(([key, value]) => {
            const [groupId, ...keyParts] = key.split(':');
            return {
                groupId,
                key: keyParts.join(':'),
                type: (0, utils_1.inferType)(value),
                value: value,
            };
        })
            .filter((item) => (input.groupId ? item.groupId === input.groupId : true))
            .filter((item) => (input.filter ? (0, utils_1.filterItem)(item, input.filter) : true));
    }
    async cleanup() { }
    _makeKey(traceId, key) {
        return `${traceId}:${key}`;
    }
}
exports.MemoryStateAdapter = MemoryStateAdapter;
