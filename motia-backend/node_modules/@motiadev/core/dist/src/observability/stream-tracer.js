"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamTracer = void 0;
const create_trace_1 = require("./create-trace");
class StreamTracer {
    constructor(manager, traceGroup, trace, logger) {
        this.manager = manager;
        this.traceGroup = traceGroup;
        this.trace = trace;
        logger.addListener((level, msg, args) => {
            this.addEvent({
                type: 'log',
                timestamp: Date.now(),
                level,
                message: msg,
                metadata: args,
            });
        });
    }
    end(err) {
        if (this.trace.endTime) {
            // avoiding updating twice
            return;
        }
        this.trace.status = err ? 'failed' : 'completed';
        this.trace.endTime = Date.now();
        this.trace.error = err;
        this.traceGroup.metadata.completedSteps++;
        this.traceGroup.metadata.activeSteps--;
        if (this.traceGroup.metadata.activeSteps === 0) {
            if (this.traceGroup.status === 'running') {
                this.traceGroup.status = 'completed';
            }
            this.traceGroup.endTime = Date.now();
        }
        if (err) {
            this.traceGroup.status = 'failed';
        }
        this.manager.updateTrace();
        this.manager.updateTraceGroup();
    }
    stateOperation(operation, input) {
        this.addEvent({
            type: 'state',
            timestamp: Date.now(),
            operation,
            data: input,
        });
    }
    emitOperation(topic, data, success) {
        this.addEvent({
            type: 'emit',
            timestamp: Date.now(),
            topic,
            success,
            data,
        });
    }
    streamOperation(streamName, operation, input) {
        if (operation === 'set') {
            const lastEvent = this.trace.events[this.trace.events.length - 1];
            if (lastEvent &&
                lastEvent.type === 'stream' &&
                lastEvent.streamName === streamName &&
                lastEvent.data.groupId === input.groupId &&
                lastEvent.data.id === input.id) {
                lastEvent.calls++;
                lastEvent.data.data = input.data;
                lastEvent.maxTimestamp = Date.now();
                this.traceGroup.lastActivity = lastEvent.maxTimestamp;
                this.manager.updateTrace();
                this.manager.updateTraceGroup();
                return;
            }
        }
        this.addEvent({
            type: 'stream',
            timestamp: Date.now(),
            operation,
            data: input,
            streamName,
            calls: 1,
        });
    }
    child(step, logger) {
        const trace = (0, create_trace_1.createTrace)(this.traceGroup, step);
        const manager = this.manager.child(trace);
        return new StreamTracer(manager, this.traceGroup, trace, logger);
    }
    addEvent(event) {
        this.trace.events.push(event);
        this.traceGroup.lastActivity = event.timestamp;
        this.manager.updateTrace();
        this.manager.updateTraceGroup();
    }
}
exports.StreamTracer = StreamTracer;
