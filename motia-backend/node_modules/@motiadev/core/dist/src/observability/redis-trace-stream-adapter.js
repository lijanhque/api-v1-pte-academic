"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisTraceStreamAdapter = void 0;
const stream_adapter_interface_1 = require("../adapters/interfaces/stream-adapter.interface");
const TRACE_TTL_SECONDS = 3 * 24 * 60 * 60;
class RedisTraceStreamAdapter extends stream_adapter_interface_1.StreamAdapter {
    constructor(streamName, client, ttl = TRACE_TTL_SECONDS) {
        super(streamName);
        this.keyPrefix = 'motia:trace:';
        this.client = client;
        this.ttl = ttl;
    }
    makeGroupKey(groupId) {
        return `${this.keyPrefix}${groupId}`;
    }
    async get(groupId, id) {
        const hashKey = this.makeGroupKey(groupId);
        const value = await this.client.hGet(hashKey, id);
        return value ? JSON.parse(value) : null;
    }
    async set(groupId, id, data) {
        const hashKey = this.makeGroupKey(groupId);
        const item = { ...data, id };
        const itemJson = JSON.stringify(item);
        const existed = await this.client.hExists(hashKey, id);
        const eventType = existed ? 'update' : 'create';
        await Promise.all([
            this.client.hSet(hashKey, id, itemJson),
            this.send({ groupId, id }, { type: eventType, data: item }),
            this.client.expire(hashKey, this.ttl),
        ]);
        return item;
    }
    async delete(groupId, id) {
        const hashKey = this.makeGroupKey(groupId);
        const value = await this.client.hGet(hashKey, id);
        if (!value)
            return null;
        const item = JSON.parse(value);
        await Promise.all([this.client.hDel(hashKey, id), this.send({ groupId, id }, { type: 'delete', data: item })]);
        return item;
    }
    async getGroup(groupId) {
        const hashKey = this.makeGroupKey(groupId);
        const values = await this.client.hGetAll(hashKey);
        const items = Object.values(values).map((v) => JSON.parse(v));
        const sortDesc = (a, b) => {
            const aTime = a.startTime || 0;
            const bTime = b.startTime || 0;
            return aTime - bTime;
        };
        return items.sort(sortDesc);
    }
    async send(channel, event) {
        const channelKey = channel.id
            ? `${this.keyPrefix}events:${this.streamName}:${channel.groupId}:${channel.id}`
            : `${this.keyPrefix}events:${this.streamName}:${channel.groupId}`;
        await this.client.publish(channelKey, JSON.stringify(event));
    }
    async clear(groupId) {
        const hashKey = this.makeGroupKey(groupId);
        await this.client.del(hashKey);
    }
}
exports.RedisTraceStreamAdapter = RedisTraceStreamAdapter;
