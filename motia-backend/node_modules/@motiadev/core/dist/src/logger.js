"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.globalLogger = exports.Logger = void 0;
const pretty_print_1 = require("./pretty-print");
const logLevel = process.env.LOG_LEVEL ?? 'info';
const isDebugEnabled = logLevel === 'debug';
const isInfoEnabled = ['info', 'debug'].includes(logLevel);
const isWarnEnabled = ['warn', 'info', 'debug', 'trace'].includes(logLevel);
class Logger {
    constructor(isVerbose = false, meta = {}, coreListeners = []) {
        this.isVerbose = isVerbose;
        this.meta = meta;
        this.coreListeners = coreListeners;
        /**
         * Why do we need two level of listeners?
         *
         * Core listeners pass along to children loggers.
         *
         * However, base listeners do not pass along to children loggers.
         * Those are specific to each logger in the hierarchy.
         */
        this.listeners = [];
    }
    child(meta) {
        return new Logger(this.isVerbose, { ...this.meta, ...meta }, this.coreListeners);
    }
    _log(level, msg, args) {
        const time = Date.now();
        const meta = { ...this.meta, ...(args ?? {}) };
        (0, pretty_print_1.prettyPrint)({ level, time, msg, ...meta }, !this.isVerbose);
        this.coreListeners.forEach((listener) => listener(level, msg, meta));
        this.listeners.forEach((listener) => listener(level, msg, meta));
    }
    info(message, args) {
        if (isInfoEnabled) {
            this._log('info', message, args);
        }
    }
    error(message, args) {
        this._log('error', message, args);
    }
    debug(message, args) {
        if (isDebugEnabled) {
            this._log('debug', message, args);
        }
    }
    warn(message, args) {
        if (isWarnEnabled) {
            this._log('warn', message, args);
        }
    }
    log(args) {
        this._log(args.level ?? 'info', args.msg, args);
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
}
exports.Logger = Logger;
exports.globalLogger = new Logger();
