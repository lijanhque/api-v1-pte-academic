"use strict";
// Helper functions
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateFlow = exports.generateStepId = exports.STEP_NAMESPACE = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const get_step_language_1 = require("../get-step-language");
const guards_1 = require("../guards");
const getNodeComponentPath = (filePath) => {
    const filePathWithoutExtension = filePath.replace(/\.[^/.]+$/, '');
    const tsxPath = filePathWithoutExtension + '.tsx';
    const jsxPath = filePathWithoutExtension + '.jsx';
    if (fs_1.default.existsSync(tsxPath))
        return tsxPath;
    if (fs_1.default.existsSync(jsxPath))
        return jsxPath;
};
const getRelativePath = (filePath) => {
    const baseDir = process.cwd();
    return path_1.default.relative(baseDir, filePath);
};
const createEdge = (sourceId, targetId, topic, label, variant, conditional) => ({
    id: `${sourceId}-${targetId}`,
    source: sourceId,
    target: targetId,
    data: {
        variant,
        label,
        topic,
        labelVariant: conditional ? 'conditional' : 'default',
    },
});
const processEmit = (emit) => {
    const isString = typeof emit === 'string';
    return {
        topic: isString ? emit : emit.topic,
        label: isString ? undefined : emit.label,
        conditional: isString ? undefined : emit.conditional,
    };
};
const createEdgesForEmits = (sourceStep, targetSteps, emits, variant) => {
    const edges = [];
    emits.forEach((emit) => {
        const { topic, label, conditional } = processEmit(emit);
        targetSteps.forEach((targetStep) => {
            if (targetStep.subscribes?.includes(topic) || targetStep.virtualSubscribes?.includes(topic)) {
                edges.push(createEdge(sourceStep.id, targetStep.id, topic, label, variant, conditional));
            }
        });
    });
    return edges;
};
const createBaseStepResponse = (step, id) => ({
    id,
    name: step.config.name,
    description: step.config.description,
    nodeComponentPath: getNodeComponentPath(step.filePath),
    filePath: getRelativePath(step.filePath),
    language: (0, get_step_language_1.getStepLanguage)(step.filePath),
    virtualEmits: step.config.virtualEmits ?? undefined,
    virtualSubscribes: step.config.virtualSubscribes ?? undefined,
});
const createApiStepResponse = (step, id) => {
    if (!(0, guards_1.isApiStep)(step)) {
        throw new Error('Attempted to create API step response with non-API step');
    }
    return {
        ...createBaseStepResponse(step, id),
        type: 'api',
        emits: step.config.emits,
        subscribes: step.config.virtualSubscribes ?? undefined,
        action: 'webhook',
        webhookUrl: `${step.config.method} ${step.config.path}`,
        bodySchema: step.config.bodySchema ?? undefined,
    };
};
const createEventStepResponse = (step, id) => {
    if (!(0, guards_1.isEventStep)(step)) {
        throw new Error('Attempted to create Event step response with non-Event step');
    }
    return {
        ...createBaseStepResponse(step, id),
        type: 'event',
        emits: step.config.emits,
        subscribes: step.config.subscribes,
    };
};
const createNoopStepResponse = (step, id) => {
    if (!(0, guards_1.isNoopStep)(step)) {
        throw new Error('Attempted to create Noop step response with non-Noop step');
    }
    return {
        ...createBaseStepResponse(step, id),
        type: 'noop',
        emits: [],
        subscribes: step.config.virtualSubscribes,
    };
};
const createCronStepResponse = (step, id) => {
    if (!(0, guards_1.isCronStep)(step)) {
        throw new Error('Attempted to create Cron step response with non-Cron step');
    }
    return {
        ...createBaseStepResponse(step, id),
        type: 'cron',
        emits: step.config.emits,
        cronExpression: step.config.cron,
    };
};
exports.STEP_NAMESPACE = '7f1c3ff2-9b00-4d0a-bdd7-efb8bca49d4f';
const generateStepId = (filePath) => {
    return (0, uuid_1.v5)(filePath, exports.STEP_NAMESPACE);
};
exports.generateStepId = generateStepId;
const createStepResponse = (step) => {
    const id = (0, exports.generateStepId)(step.filePath);
    if ((0, guards_1.isApiStep)(step))
        return createApiStepResponse(step, id);
    if ((0, guards_1.isEventStep)(step))
        return createEventStepResponse(step, id);
    if ((0, guards_1.isNoopStep)(step))
        return createNoopStepResponse(step, id);
    if ((0, guards_1.isCronStep)(step))
        return createCronStepResponse(step, id);
    throw new Error(`Unknown step type for step: ${step.config.name}`);
};
const createEdgesForStep = (sourceStep, allSteps) => {
    const regularEdges = createEdgesForEmits(sourceStep, allSteps, sourceStep.emits, 'event');
    const virtualEdges = sourceStep.virtualEmits
        ? createEdgesForEmits(sourceStep, allSteps, sourceStep.virtualEmits, 'virtual')
        : [];
    return [...regularEdges, ...virtualEdges];
};
const generateFlow = (flowId, flowSteps) => {
    const steps = flowSteps.map(createStepResponse);
    const edges = steps.flatMap((step) => createEdgesForStep(step, steps));
    return { id: flowId, name: flowId, steps, edges };
};
exports.generateFlow = generateFlow;
