"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueueManager = exports.MaxRetriesError = exports.HandlerTimeoutError = exports.QueueError = void 0;
const crypto_1 = require("crypto");
const events_1 = require("events");
const logger_1 = require("./logger");
class QueueError extends Error {
    constructor(message) {
        super(message);
        this.name = 'QueueError';
    }
}
exports.QueueError = QueueError;
class HandlerTimeoutError extends QueueError {
    constructor(message) {
        super(message);
        this.name = 'HandlerTimeoutError';
    }
}
exports.HandlerTimeoutError = HandlerTimeoutError;
class MaxRetriesError extends QueueError {
    constructor(message, attempts) {
        super(message);
        this.attempts = attempts;
        this.name = 'MaxRetriesError';
    }
}
exports.MaxRetriesError = MaxRetriesError;
class QueueManager {
    constructor(logger) {
        this.queues = {};
        this.subscriptions = {};
        this.lockedGroups = new Set();
        this.queueEmitter = new events_1.EventEmitter();
        this.scheduledTimeouts = new Map();
        this.metrics = new Map();
        this.processingMessages = new Set();
        this.logger = logger || logger_1.globalLogger;
        this.queueEmitter.on('process', (topic) => {
            this.processQueue(topic);
        });
    }
    initMetrics(topic) {
        if (!this.metrics.has(topic)) {
            this.metrics.set(topic, {
                queueDepth: 0,
                processingCount: 0,
                retriesCount: 0,
                dlqCount: 0,
            });
        }
    }
    updateMetric(topic, key, delta) {
        this.initMetrics(topic);
        const metrics = this.metrics.get(topic);
        metrics[key] = Math.max(0, metrics[key] + delta);
    }
    processQueue(topic) {
        const queue = this.queues[topic];
        if (!queue || queue.length === 0) {
            return;
        }
        const now = Date.now();
        const visibleMessages = queue.filter((msg) => msg.visibleAt <= now && !this.processingMessages.has(msg.id));
        for (const message of visibleMessages) {
            if (message.queueConfig.type === 'fifo' && message.messageGroupId) {
                const lockKey = `${topic}:${message.messageGroupId}`;
                if (this.lockedGroups.has(lockKey)) {
                    continue;
                }
                this.processingMessages.add(message.id);
                this.lockedGroups.add(lockKey);
                void this.processMessage(topic, message, lockKey);
            }
            else {
                this.processingMessages.add(message.id);
                void this.processMessage(topic, message);
            }
        }
    }
    async processMessage(topic, message, lockKey) {
        const handlers = this.subscriptions[topic] || [];
        const handler = handlers.find((s) => s.internalSubscriptionId === message.internalSubscriptionId) ||
            handlers.find((s) => s.subscriptionId === message.subscriptionId) ||
            handlers[0];
        if (!handler) {
            this.processingMessages.delete(message.id);
            this.removeMessageFromQueue(topic, message.id);
            if (lockKey) {
                this.lockedGroups.delete(lockKey);
            }
            return;
        }
        const handlerChanged = message.internalSubscriptionId !== handler.internalSubscriptionId;
        if (handlerChanged && message.attempts > 0) {
            message.attempts = 0;
            message.internalSubscriptionId = handler.internalSubscriptionId;
            message.subscriptionId = handler.subscriptionId;
            message.visibleAt = Date.now();
        }
        this.updateMetric(topic, 'processingCount', 1);
        try {
            await handler.handler(message.event);
            this.updateMetric(topic, 'processingCount', -1);
            this.processingMessages.delete(message.id);
            this.removeMessageFromQueue(topic, message.id);
            if (lockKey) {
                this.lockedGroups.delete(lockKey);
            }
            this.scheduleProcessing(topic, 0);
        }
        catch (error) {
            this.updateMetric(topic, 'processingCount', -1);
            this.processingMessages.delete(message.id);
            message.attempts++;
            if (message.attempts >= handler.queueConfig.maxRetries) {
                const maxRetriesError = new MaxRetriesError(`Message failed after ${message.attempts} attempts`, message.attempts);
                this.logger.error('[Queue DLQ] Message moved to dead-letter queue after max retries', {
                    topic,
                    messageId: message.id,
                    attempts: message.attempts,
                    originalError: error instanceof Error ? error.message : 'Unknown error',
                    error: maxRetriesError.message,
                });
                this.updateMetric(topic, 'dlqCount', 1);
                this.removeMessageFromQueue(topic, message.id);
                if (lockKey) {
                    this.lockedGroups.delete(lockKey);
                }
                this.scheduleProcessing(topic, 0);
            }
            else {
                this.updateMetric(topic, 'retriesCount', 1);
                message.visibleAt = Date.now() + handler.queueConfig.visibilityTimeout * 1000;
                if (lockKey) {
                    this.lockedGroups.delete(lockKey);
                }
                this.scheduleProcessing(topic, handler.queueConfig.visibilityTimeout * 1000);
            }
        }
    }
    removeMessageFromQueue(topic, messageId) {
        const queue = this.queues[topic];
        if (!queue) {
            return;
        }
        const index = queue.findIndex((msg) => msg.id === messageId);
        if (index !== -1) {
            queue.splice(index, 1);
            this.updateMetric(topic, 'queueDepth', -1);
        }
        if (queue.length === 0) {
            delete this.queues[topic];
        }
    }
    scheduleProcessing(topic, delayMs) {
        const existingTimeout = this.scheduledTimeouts.get(topic);
        if (existingTimeout) {
            clearTimeout(existingTimeout);
        }
        const timeout = setTimeout(() => {
            this.queueEmitter.emit('process', topic);
            this.scheduledTimeouts.delete(topic);
        }, delayMs);
        this.scheduledTimeouts.set(topic, timeout);
    }
    async enqueue(topic, event, messageGroupId) {
        const handlers = this.subscriptions[topic] || [];
        if (handlers.length === 0) {
            return;
        }
        const effectiveMessageGroupId = messageGroupId ?? event.messageGroupId;
        for (const subscription of handlers) {
            const delayMs = subscription.queueConfig.delaySeconds * 1000;
            const visibleAt = Date.now() + delayMs;
            const queuedMessage = {
                id: (0, crypto_1.randomUUID)(),
                event,
                attempts: 0,
                visibleAt,
                messageGroupId: effectiveMessageGroupId,
                queueConfig: subscription.queueConfig,
                subscriptionId: subscription.subscriptionId,
                internalSubscriptionId: subscription.internalSubscriptionId,
            };
            if (!this.queues[topic]) {
                this.queues[topic] = [];
            }
            this.queues[topic].push(queuedMessage);
            this.updateMetric(topic, 'queueDepth', 1);
            this.scheduleProcessing(topic, delayMs);
        }
    }
    subscribe(topic, handler, queueConfig, subscriptionId) {
        if (!this.subscriptions[topic]) {
            this.subscriptions[topic] = [];
        }
        const internalSubscriptionId = (0, crypto_1.randomUUID)();
        this.subscriptions[topic].push({ handler, queueConfig, subscriptionId, internalSubscriptionId });
        if (this.queues[topic] && this.queues[topic].length > 0) {
            const now = Date.now();
            let madeVisible = false;
            for (const message of this.queues[topic]) {
                if (message.internalSubscriptionId !== internalSubscriptionId && message.attempts > 0) {
                    message.visibleAt = now;
                    madeVisible = true;
                }
            }
            if (madeVisible) {
                this.scheduleProcessing(topic, 0);
            }
        }
    }
    unsubscribe(topic, handler) {
        if (!this.subscriptions[topic]) {
            return;
        }
        this.subscriptions[topic] = this.subscriptions[topic].filter((sub) => sub.handler !== handler);
        if (this.subscriptions[topic].length === 0) {
            delete this.subscriptions[topic];
            const hasQueuedMessages = this.queues[topic] && this.queues[topic].length > 0;
            if (!hasQueuedMessages) {
                const timeout = this.scheduledTimeouts.get(topic);
                if (timeout) {
                    clearTimeout(timeout);
                    this.scheduledTimeouts.delete(topic);
                }
            }
        }
    }
    getMetrics(topic) {
        return this.metrics.get(topic);
    }
    getAllMetrics() {
        const result = {};
        this.metrics.forEach((metrics, topic) => {
            result[topic] = { ...metrics };
        });
        return result;
    }
    reset() {
        this.scheduledTimeouts.forEach((timeout) => clearTimeout(timeout));
        this.scheduledTimeouts.clear();
        this.queueEmitter.removeAllListeners();
        this.queues = {};
        this.subscriptions = {};
        this.lockedGroups = new Set();
        this.processingMessages = new Set();
        this.metrics.clear();
    }
}
exports.QueueManager = QueueManager;
