"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSocketServer = void 0;
const ws_1 = require("ws");
const createSocketServer = ({ server, onJoin, onJoinGroup }) => {
    const socketServer = new ws_1.Server({ server });
    const rooms = {};
    const subscriptions = new Map();
    const getRoom = (message) => {
        return message.id ? `${message.streamName}:id:${message.id}` : `${message.streamName}:group-id:${message.groupId}`;
    };
    socketServer.on('connection', (socket) => {
        subscriptions.set(socket, new Set());
        socket.on('message', async (payload) => {
            const message = JSON.parse(payload.toString());
            if (message.type === 'join') {
                const room = getRoom(message.data);
                if (!rooms[room]) {
                    rooms[room] = new Map();
                }
                if (message.data.id) {
                    const item = await onJoin(message.data.streamName, message.data.groupId, message.data.id);
                    if (item) {
                        const resultMessage = {
                            timestamp: Date.now(),
                            streamName: message.data.streamName,
                            groupId: message.data.groupId,
                            id: message.data.id,
                            event: { type: 'sync', data: item },
                        };
                        socket.send(JSON.stringify(resultMessage));
                    }
                }
                else {
                    const items = await onJoinGroup(message.data.streamName, message.data.groupId);
                    if (items) {
                        const resultMessage = {
                            timestamp: Date.now(),
                            streamName: message.data.streamName,
                            groupId: message.data.groupId,
                            event: { type: 'sync', data: items },
                        };
                        socket.send(JSON.stringify(resultMessage));
                    }
                }
                rooms[room].set(message.data.subscriptionId, socket);
                subscriptions.get(socket)?.add([room, message.data.subscriptionId]);
            }
            else if (message.type === 'leave') {
                const room = getRoom(message.data);
                if (rooms[room]) {
                    rooms[room].delete(message.data.subscriptionId);
                }
            }
        });
        socket.on('close', () => {
            subscriptions.get(socket)?.forEach(([room, subscriptionId]) => {
                rooms[room]?.delete(subscriptionId);
            });
            subscriptions.delete(socket);
        });
    });
    const pushEvent = (message) => {
        const { groupId, streamName, id } = message;
        const groupRoom = getRoom({ streamName, groupId });
        const eventMessage = JSON.stringify({ timestamp: Date.now(), ...message });
        if (rooms[groupRoom]) {
            rooms[groupRoom].forEach((socket) => socket.send(eventMessage));
        }
        if (id) {
            const itemRoom = getRoom({ groupId, streamName, id });
            if (rooms[itemRoom]) {
                rooms[itemRoom].forEach((socket) => socket.send(eventMessage));
            }
        }
    };
    return { pushEvent, socketServer };
};
exports.createSocketServer = createSocketServer;
