"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMermaidGenerator = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const guards_1 = require("./guards");
// Pure function to ensure diagrams directory exists
const ensureDiagramsDirectory = (diagramsDir) => {
    if (!fs_1.default.existsSync(diagramsDir)) {
        fs_1.default.mkdirSync(diagramsDir, { recursive: true });
    }
};
// Pure function to get node ID
const getNodeId = (step, baseDir) => {
    // Get relative path from the base directory
    const relativePath = path_1.default.relative(baseDir, step.filePath);
    // Remove common file extensions
    const pathWithoutExtension = relativePath.replace(/\.(ts|js|tsx|jsx)$/, '');
    // Replace slashes with underscores and dots with underscores
    // Only keep alphanumeric characters and underscores
    return pathWithoutExtension.replace(/[^a-zA-Z0-9]/g, '_');
};
// Pure function to get node label
const getNodeLabel = (step) => {
    // Get display name for node
    const displayName = step.config.name || path_1.default.basename(step.filePath, path_1.default.extname(step.filePath));
    // Add node type prefix to help distinguish types
    let prefix = '';
    if ((0, guards_1.isApiStep)(step))
        prefix = 'ðŸŒ ';
    else if ((0, guards_1.isEventStep)(step))
        prefix = 'âš¡ ';
    else if ((0, guards_1.isCronStep)(step))
        prefix = 'â° ';
    else if ((0, guards_1.isNoopStep)(step))
        prefix = 'âš™ï¸ ';
    // Create a node label with the step name
    return `["${prefix}${displayName}"]`;
};
// Pure function to get node style
const getNodeStyle = (step) => {
    // Apply style class based on step type
    if ((0, guards_1.isApiStep)(step))
        return ':::apiStyle';
    if ((0, guards_1.isEventStep)(step))
        return ':::eventStyle';
    if ((0, guards_1.isCronStep)(step))
        return ':::cronStyle';
    if ((0, guards_1.isNoopStep)(step))
        return ':::noopStyle';
    return '';
};
// Pure function to generate connections
const generateConnections = (emits, sourceStep, steps, sourceId, baseDir) => {
    const connections = [];
    if (!emits || !Array.isArray(emits) || emits.length === 0) {
        return '';
    }
    // Helper function to check if a step subscribes to a topic
    const stepSubscribesToTopic = (step, topic) => {
        // Event steps use regular subscribes
        if ((0, guards_1.isEventStep)(step) &&
            step.config.subscribes &&
            Array.isArray(step.config.subscribes) &&
            step.config.subscribes.includes(topic)) {
            return true;
        }
        // Noop and API steps use virtualSubscribes
        if (((0, guards_1.isNoopStep)(step) || (0, guards_1.isApiStep)(step)) &&
            step.config.virtualSubscribes &&
            Array.isArray(step.config.virtualSubscribes) &&
            step.config.virtualSubscribes.includes(topic)) {
            return true;
        }
        return false;
    };
    emits.forEach((emit) => {
        const topic = typeof emit === 'string' ? emit : emit.topic;
        const label = typeof emit === 'string' ? topic : emit.label || topic;
        steps.forEach((targetStep) => {
            if (stepSubscribesToTopic(targetStep, topic)) {
                const targetId = getNodeId(targetStep, baseDir);
                connections.push(`    ${sourceId} -->|${label}| ${targetId}`);
            }
        });
    });
    return connections.join('\n');
};
// Pure function to generate flow diagram
const generateFlowDiagram = (flowName, steps, baseDir) => {
    // Start mermaid flowchart with top-down direction
    let diagram = `flowchart TD\n`;
    // Add class definitions for styling with explicit text color
    const classDefinitions = [
        `    classDef apiStyle fill:#f96,stroke:#333,stroke-width:2px,color:#fff`,
        `    classDef eventStyle fill:#69f,stroke:#333,stroke-width:2px,color:#fff`,
        `    classDef cronStyle fill:#9c6,stroke:#333,stroke-width:2px,color:#fff`,
        `    classDef noopStyle fill:#3f3a50,stroke:#333,stroke-width:2px,color:#fff`,
    ];
    diagram += classDefinitions.join('\n') + '\n';
    // Check if we have any steps
    if (!steps || steps.length === 0) {
        return diagram + '    empty[No steps in this flow]';
    }
    // Create node definitions with proper format
    steps.forEach((step) => {
        const nodeId = getNodeId(step, baseDir);
        const nodeLabel = getNodeLabel(step);
        const nodeStyle = getNodeStyle(step);
        diagram += `    ${nodeId}${nodeLabel}${nodeStyle}\n`;
    });
    // Create connections between nodes
    let connectionsStr = '';
    steps.forEach((sourceStep) => {
        const sourceId = getNodeId(sourceStep, baseDir);
        // Helper function to process emissions if they exist
        function processEmissions(emissionsArray, stepSource, stepsCollection, sourceIdentifier) {
            if (emissionsArray && Array.isArray(emissionsArray)) {
                return generateConnections(emissionsArray, stepSource, stepsCollection, sourceIdentifier, baseDir);
            }
            return '';
        }
        // Semantic variables to clarify which step types support which emission types
        const supportsEmits = (0, guards_1.isApiStep)(sourceStep) || (0, guards_1.isEventStep)(sourceStep) || (0, guards_1.isCronStep)(sourceStep);
        const supportsVirtualEmits = supportsEmits || (0, guards_1.isNoopStep)(sourceStep);
        // Process regular emissions if supported
        if (supportsEmits) {
            const emitConnections = processEmissions(sourceStep.config.emits, sourceStep, steps, sourceId);
            if (emitConnections) {
                connectionsStr += emitConnections + '\n';
            }
        }
        // Process virtual emissions if supported
        if (supportsVirtualEmits) {
            const virtualEmitConnections = processEmissions(sourceStep.config.virtualEmits, sourceStep, steps, sourceId);
            if (virtualEmitConnections) {
                connectionsStr += virtualEmitConnections + '\n';
            }
        }
    });
    // Add connections to the diagram
    diagram += connectionsStr;
    return diagram;
};
// Function to save a diagram to a file
const saveDiagram = (diagramsDir, flowName, diagram) => {
    const filePath = path_1.default.join(diagramsDir, `${flowName}.mmd`);
    fs_1.default.writeFileSync(filePath, diagram);
};
// Function to remove a diagram file
const removeDiagram = (diagramsDir, flowName) => {
    const filePath = path_1.default.join(diagramsDir, `${flowName}.mmd`);
    if (fs_1.default.existsSync(filePath)) {
        fs_1.default.unlinkSync(filePath);
    }
};
// Function to generate and save a diagram
const generateAndSaveDiagram = (diagramsDir, flowName, flow, baseDir) => {
    const diagram = generateFlowDiagram(flowName, flow.steps, baseDir);
    saveDiagram(diagramsDir, flowName, diagram);
};
// Main exported function that creates the mermaid generator
const createMermaidGenerator = (baseDir) => {
    const diagramsDir = path_1.default.join(baseDir, '.mermaid');
    ensureDiagramsDirectory(diagramsDir);
    // Event handlers
    const handleFlowCreated = (flowName, flow) => {
        generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir);
    };
    const handleFlowUpdated = (flowName, flow) => {
        generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir);
    };
    const handleFlowRemoved = (flowName) => {
        removeDiagram(diagramsDir, flowName);
    };
    // Initialize function to hook into LockedData events
    const initialize = (lockedData) => {
        // Hook into flow events
        lockedData.on('flow-created', (flowName) => {
            handleFlowCreated(flowName, lockedData.flows[flowName]);
        });
        lockedData.on('flow-updated', (flowName) => {
            handleFlowUpdated(flowName, lockedData.flows[flowName]);
        });
        lockedData.on('flow-removed', (flowName) => {
            handleFlowRemoved(flowName);
        });
        // Generate diagrams for all existing flows
        if (lockedData.flows && typeof lockedData.flows === 'object') {
            Object.entries(lockedData.flows).forEach(([flowName, flow]) => {
                generateAndSaveDiagram(diagramsDir, flowName, flow, baseDir);
            });
        }
    };
    // Return the public API
    return {
        initialize,
    };
};
exports.createMermaidGenerator = createMermaidGenerator;
