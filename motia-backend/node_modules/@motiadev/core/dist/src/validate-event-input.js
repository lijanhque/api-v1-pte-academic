"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateEventInput = void 0;
const ajv_1 = __importDefault(require("ajv"));
const logger_1 = require("./logger");
const printer_1 = require("./printer");
const schema_utils_1 = require("./schema-utils");
const ajv = new ajv_1.default({ allErrors: true, strict: false });
const validateEventInput = (step, event, motia) => {
    const { data } = event;
    const logger = event.logger
        ? event.logger.child({ step: step.config.name })
        : motia.loggerFactory.create({ step: step.config.name, traceId: event.traceId });
    if (step.config.input) {
        if (data === null || typeof data !== 'object') {
            logger.warn(`⚠️ Event "${step.config.name}" received non-object data`, { data });
            return;
        }
        let compiledSchema;
        const inputSchema = step.config.input;
        try {
            compiledSchema = (0, schema_utils_1.schemaToJsonSchema)(inputSchema);
            if (!compiledSchema) {
                compiledSchema = inputSchema;
            }
        }
        catch (err) {
            logger.error(`❌ Failed to convert or compile schema for step "${step.config.name}"`, { error: err });
            logger_1.globalLogger.error('[step handler] failed to convert schema', { step: step.config.name, error: err });
            return;
        }
        let validate;
        try {
            validate = ajv.compile(compiledSchema);
        }
        catch (err) {
            logger.error(`❌ Invalid JSON schema for step "${step.config.name}"`, { error: err });
            logger_1.globalLogger.error('[step handler] invalid JSON schema', { step: step.config.name, error: err });
            return;
        }
        const valid = validate(data);
        if (!valid && validate.errors?.length) {
            const missingFields = [];
            const extraFields = [];
            const typeMismatches = [];
            for (const err of validate.errors) {
                const field = err.instancePath ? err.instancePath.replace(/^\//, '').replace(/\//g, '.') : '(root)';
                switch (err.keyword) {
                    case 'required':
                        if ('missingProperty' in err.params) {
                            missingFields.push(field === '(root)' ? err.params.missingProperty : `${field}.${err.params.missingProperty}`);
                        }
                        break;
                    case 'type':
                        typeMismatches.push(`Field "${field}": must be ${err.params.type}`);
                        break;
                    case 'additionalProperties':
                        if ('additionalProperty' in err.params) {
                            extraFields.push(field === '(root)' ? err.params.additionalProperty : `${field}.${err.params.additionalProperty}`);
                        }
                        break;
                    default:
                        typeMismatches.push(`Field "${field}": ${err.message}`);
                }
            }
            const printer = motia?.printer ?? new printer_1.Printer(process.cwd());
            printer.printEventInputValidationError({ topic: event.topic }, { missingFields, extraFields, typeMismatches });
        }
    }
};
exports.validateEventInput = validateEventInput;
