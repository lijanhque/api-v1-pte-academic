"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeSchemas = exports.isCompatible = void 0;
const z = __importStar(require("zod"));
const schema_utils_1 = require("../schema-utils");
const schema_types_1 = require("./schema.types");
const isJsonSchema = (value) => {
    return typeof value === 'object' && value !== null && !Array.isArray(value) && typeof value !== 'boolean';
};
const isCompatible = (schema, otherSchema) => {
    if ((0, schema_types_1.isAnyOf)(schema)) {
        return schema.anyOf.every((item) => (0, exports.isCompatible)(item, otherSchema));
    }
    else if ((0, schema_types_1.isAnyOf)(otherSchema)) {
        return otherSchema.anyOf.every((item) => (0, exports.isCompatible)(schema, item));
    }
    if (schema.type !== otherSchema.type) {
        return false;
    }
    if (schema.type === 'array' && otherSchema.type === 'array') {
        if (!schema.items || !otherSchema.items) {
            return schema.items === otherSchema.items;
        }
        if (Array.isArray(schema.items) || Array.isArray(otherSchema.items)) {
            return false;
        }
        if (isJsonSchema(schema.items) && isJsonSchema(otherSchema.items)) {
            return (0, exports.isCompatible)(schema.items, otherSchema.items);
        }
        return schema.items === otherSchema.items;
    }
    if (schema.type === 'object' && otherSchema.type === 'object') {
        const schemaProps = schema.properties;
        const otherSchemaProps = otherSchema.properties;
        if (!schemaProps || !otherSchemaProps) {
            return schemaProps === otherSchemaProps;
        }
        const keysFromSchema = Object.keys(schemaProps);
        const keysFromOtherSchema = Object.keys(otherSchemaProps);
        const commonKeys = keysFromSchema.filter((key) => keysFromOtherSchema.includes(key));
        if (schema.required?.some((key) => !keysFromOtherSchema.includes(key))) {
            return false;
        }
        else if (otherSchema.required?.some((key) => !keysFromSchema.includes(key))) {
            return false;
        }
        if (commonKeys.length > 0) {
            return commonKeys.every((key) => {
                const prop1 = schemaProps[key];
                const prop2 = otherSchemaProps[key];
                if (isJsonSchema(prop1) && isJsonSchema(prop2)) {
                    return (0, exports.isCompatible)(prop1, prop2);
                }
                return prop1 === prop2;
            });
        }
    }
    return true;
};
exports.isCompatible = isCompatible;
const mergeZodSchemas = (schema, otherSchema) => {
    try {
        return z.intersection(schema, otherSchema);
    }
    catch (error) {
        throw new schema_types_1.JsonSchemaError(`Cannot merge Zod schemas: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
};
const mergeSchemas = (schema, otherSchema) => {
    if ((0, schema_utils_1.isZodSchema)(schema) && (0, schema_utils_1.isZodSchema)(otherSchema)) {
        const mergedZodSchema = mergeZodSchemas(schema, otherSchema);
        const jsonSchema = (0, schema_utils_1.schemaToJsonSchema)(mergedZodSchema);
        if (!jsonSchema) {
            throw new schema_types_1.JsonSchemaError('Failed to convert merged Zod schema to JSON Schema');
        }
        return jsonSchema;
    }
    const schemaJsonResult = (0, schema_utils_1.schemaToJsonSchema)(schema);
    const otherSchemaJsonResult = (0, schema_utils_1.schemaToJsonSchema)(otherSchema);
    if (!schemaJsonResult || !otherSchemaJsonResult) {
        throw new schema_types_1.JsonSchemaError('Cannot merge schemas: failed to convert to JSON Schema');
    }
    const schemaJson = schemaJsonResult;
    const otherSchemaJson = otherSchemaJsonResult;
    if (!(0, exports.isCompatible)(schemaJson, otherSchemaJson)) {
        throw new schema_types_1.JsonSchemaError('Cannot merge schemas of different types');
    }
    if ((0, schema_types_1.isAnyOf)(schemaJson)) {
        return {
            anyOf: schemaJson.anyOf.map((item) => (0, exports.mergeSchemas)(item, otherSchemaJson)),
        };
    }
    else if ((0, schema_types_1.isAnyOf)(otherSchemaJson)) {
        return {
            anyOf: otherSchemaJson.anyOf.map((item) => (0, exports.mergeSchemas)(schemaJson, item)),
        };
    }
    if (schemaJson.type === 'object' && otherSchemaJson.type === 'object') {
        const schemaProps = schemaJson.properties;
        const otherSchemaProps = otherSchemaJson.properties;
        if (!schemaProps || !otherSchemaProps) {
            throw new schema_types_1.JsonSchemaError('Cannot merge object schemas without properties');
        }
        const mergedProperties = { ...schemaProps, ...otherSchemaProps };
        const otherSchemaKeys = Object.keys(otherSchemaProps).reduce((acc, key) => {
            acc[key] = true;
            return acc;
        }, {});
        for (const key in schemaProps) {
            if (otherSchemaKeys[key]) {
                const prop1 = schemaProps[key];
                const prop2 = otherSchemaProps[key];
                if (isJsonSchema(prop1) && isJsonSchema(prop2)) {
                    mergedProperties[key] = (0, exports.mergeSchemas)(prop1, prop2);
                }
                else {
                    mergedProperties[key] = prop2;
                }
            }
        }
        const schemaRequired = schemaJson.required;
        const otherSchemaRequired = otherSchemaJson.required;
        const mergedRequired = new Set([...(schemaRequired ?? []), ...(otherSchemaRequired ?? [])]);
        return {
            type: 'object',
            properties: mergedProperties,
            required: Array.from(mergedRequired),
        };
    }
    if (schemaJson.type === 'array' && otherSchemaJson.type === 'array') {
        if (!schemaJson.items || !otherSchemaJson.items) {
            throw new schema_types_1.JsonSchemaError('Cannot merge array schemas without items');
        }
        if (Array.isArray(schemaJson.items) || Array.isArray(otherSchemaJson.items)) {
            throw new schema_types_1.JsonSchemaError('Cannot merge array schemas with array items');
        }
        if (!isJsonSchema(schemaJson.items) || !isJsonSchema(otherSchemaJson.items)) {
            throw new schema_types_1.JsonSchemaError('Cannot merge array schemas with non-object items');
        }
        return {
            type: 'array',
            items: (0, exports.mergeSchemas)(schemaJson.items, otherSchemaJson.items),
        };
    }
    return {
        type: schemaJson.type,
        description: (schemaJson.description ?? otherSchemaJson.description),
    };
};
exports.mergeSchemas = mergeSchemas;
