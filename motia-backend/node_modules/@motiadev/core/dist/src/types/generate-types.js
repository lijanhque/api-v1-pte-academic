"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTypesFromStreams = exports.generateTypesFromSteps = exports.generateTypesString = void 0;
const guards_1 = require("../guards");
const schema_utils_1 = require("../schema-utils");
const generate_type_from_schema_1 = require("./generate-type-from-schema");
const generate_types_from_response_1 = require("./generate-types-from-response");
const merge_schemas_1 = require("./merge-schemas");
const generateTypesString = (handlers, streams) => {
    return `/**
 * Automatically generated types for motia
 * Do NOT edit this file manually.
 * 
 * Consider adding this file to .prettierignore and eslint ignore.
 */
import { EventHandler, ApiRouteHandler, ApiResponse, MotiaStream, CronHandler } from 'motia'

declare module 'motia' {
  interface FlowContextStateStreams {
    ${Object.entries(streams)
        .map(([key, value]) => `'${key}': MotiaStream<${value}>`)
        .join('\n    ')
        .trim()}
  }

  interface Handlers {
    ${Object.entries(handlers)
        .map(([key, { type, generics }]) => `'${key}': ${type}<${generics.join(', ')}>`)
        .join('\n    ')
        .trim()}
  }
}`;
};
exports.generateTypesString = generateTypesString;
const generateTypesFromSteps = (steps, printer) => {
    const handlers = {};
    const topics = {};
    const topicsSchemas = {};
    const topicsSteps = {};
    const topicIsFifo = {};
    for (const step of steps) {
        if ((0, guards_1.isEventStep)(step)) {
            if (!step.config.input) {
                for (const topic of step.config.subscribes) {
                    if (!topics[topic]) {
                        topics[topic] = 'never';
                    }
                }
                continue;
            }
            for (const topic of step.config.subscribes) {
                const existingSchema = topicsSchemas[topic];
                topicsSteps[topic] = topicsSteps[topic] ?? [];
                topicsSteps[topic].push(step);
                const queueType = step.config.infrastructure?.queue?.type;
                if (queueType === 'fifo') {
                    topicIsFifo[topic] = true;
                }
                try {
                    const input = step.config.input;
                    const schema = existingSchema
                        ? (0, merge_schemas_1.mergeSchemas)(existingSchema, input)
                        : ((0, schema_utils_1.schemaToJsonSchema)(input) ?? input);
                    topics[topic] = (0, generate_type_from_schema_1.generateTypeFromSchema)(schema);
                    topicsSchemas[topic] = schema;
                }
                catch (error) {
                    printer.printInvalidSchema(topic, topicsSteps[topic]);
                    topics[topic] = 'never';
                }
            }
        }
    }
    const generateEmitData = (emit, step) => {
        const emits = emit
            .reduce((acc, emit) => {
            const topic = typeof emit === 'string' ? emit : emit.topic;
            const topicType = topics[topic];
            if (topicType) {
                const isFifo = topicIsFifo[topic];
                if (isFifo) {
                    acc.push(`{ topic: '${topic.replace(/'/g, "\\'")}'; data: ${topicType}; messageGroupId: string }`);
                }
                else {
                    acc.push(`{ topic: '${topic.replace(/'/g, "\\'")}'; data: ${topicType} }`);
                }
            }
            else {
                printer.printInvalidEmitConfiguration(step, topic);
            }
            return acc;
        }, [])
            .join(' | ');
        return emits.length === 0 ? 'never' : emits;
    };
    for (const step of steps) {
        const emits = 'emits' in step.config ? generateEmitData(step.config.emits, step) : 'never';
        if ((0, guards_1.isEventStep)(step)) {
            const input = step.config.input ? (0, generate_type_from_schema_1.generateTypeFromSchema)(step.config.input) : 'never';
            handlers[step.config.name] = { type: 'EventHandler', generics: [input, emits] };
        }
        else if ((0, guards_1.isApiStep)(step)) {
            const input = step.config.bodySchema
                ? (0, generate_type_from_schema_1.generateTypeFromSchema)(step.config.bodySchema)
                : 'Record<string, unknown>';
            const result = step.config.responseSchema
                ? (0, generate_types_from_response_1.generateTypesFromResponse)(step.config.responseSchema)
                : 'unknown';
            handlers[step.config.name] = { type: 'ApiRouteHandler', generics: [input, result, emits] };
        }
        else if ((0, guards_1.isCronStep)(step)) {
            handlers[step.config.name] = { type: 'CronHandler', generics: [emits] };
        }
    }
    return handlers;
};
exports.generateTypesFromSteps = generateTypesFromSteps;
const generateTypesFromStreams = (streams) => {
    return Object.entries(streams).reduce((acc, [key, stream]) => {
        if (!stream.hidden) {
            acc[key] = (0, generate_type_from_schema_1.generateTypeFromSchema)(stream.config.schema);
        }
        return acc;
    }, {});
};
exports.generateTypesFromStreams = generateTypesFromStreams;
