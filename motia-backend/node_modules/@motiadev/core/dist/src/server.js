"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createServer = void 0;
const body_parser_1 = __importDefault(require("body-parser"));
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const utils_1 = require("./analytics/utils");
const call_step_file_1 = require("./call-step-file");
const cron_handler_1 = require("./cron-handler");
const analytics_endpoint_1 = require("./endpoints/analytics-endpoint");
const flows_config_endpoint_1 = require("./endpoints/flows-config-endpoint");
const flows_endpoint_1 = require("./endpoints/flows-endpoint");
const step_endpoint_1 = require("./endpoints/step-endpoint");
const generate_trace_id_1 = require("./generate-trace-id");
const guards_1 = require("./guards");
const logger_1 = require("./logger");
const logger_factory_1 = require("./logger-factory");
const tracer_1 = require("./observability/tracer");
const printer_1 = require("./printer");
const socket_server_1 = require("./socket-server");
const step_handlers_1 = require("./step-handlers");
const steps_1 = require("./steps");
const redis_logs_stream_1 = require("./streams/redis-logs-stream");
const createServer = (lockedData, state, config, adapters, configureApp) => {
    const printer = config.printer ?? new printer_1.Printer(process.cwd());
    const app = (0, express_1.default)();
    if (configureApp) {
        configureApp(app);
    }
    const server = http_1.default.createServer(app);
    const { pushEvent, socketServer } = (0, socket_server_1.createSocketServer)({
        server,
        onJoin: async (streamName, groupId, id) => {
            const streams = lockedData.getStreams();
            const stream = streams[streamName];
            if (stream) {
                const result = await stream().get(groupId, id);
                delete result?.__motia; // deleting because we don't need it in the socket
                return result;
            }
        },
        onJoinGroup: async (streamName, groupId) => {
            const streams = lockedData.getStreams();
            const stream = streams[streamName];
            if (stream) {
                const result = stream ? await stream().getGroup(groupId) : [];
                return result.map(({ __motia, ...rest }) => rest);
            }
        },
    });
    lockedData.applyStreamWrapper((streamName, stream) => {
        return () => {
            const main = stream();
            const wrapObject = (groupId, id, object) => {
                if (!object) {
                    return null;
                }
                return {
                    ...object,
                    __motia: { type: 'state-stream', streamName, groupId, id },
                };
            };
            const mainGetGroup = main.getGroup;
            const mainGet = main.get;
            const mainSet = main.set;
            const mainDelete = main.delete;
            main.send = async (channel, event) => {
                pushEvent({ streamName, ...channel, event: { type: 'event', event } });
            };
            main.getGroup = async (groupId) => {
                const result = await mainGetGroup.apply(main, [groupId]);
                return result.map((object) => wrapObject(groupId, object.id, object));
            };
            main.get = async (groupId, id) => {
                const result = await mainGet.apply(main, [groupId, id]);
                return wrapObject(groupId, id, result);
            };
            main.set = async (groupId, id, data) => {
                if (!data) {
                    return null;
                }
                const exists = await main.get(groupId, id);
                const updated = await mainSet.apply(main, [groupId, id, data]);
                const result = updated ?? data;
                const wrappedResult = wrapObject(groupId, id, result);
                const type = exists ? 'update' : 'create';
                pushEvent({ streamName, groupId, id, event: { type, data: result } });
                return wrappedResult;
            };
            main.delete = async (groupId, id) => {
                const result = await mainDelete.apply(main, [groupId, id]);
                pushEvent({ streamName, groupId, id, event: { type: 'delete', data: result } });
                return wrapObject(groupId, id, result);
            };
            return main;
        };
    });
    const logStream = lockedData.createStream({
        filePath: '__motia.logs',
        hidden: true,
        config: {
            name: '__motia.logs',
            baseConfig: {
                storageType: 'custom',
                factory: () => {
                    return new redis_logs_stream_1.RedisLogsStream(lockedData.redisClient);
                },
            },
            schema: null,
        },
    })();
    const allSteps = [...steps_1.systemSteps, ...lockedData.activeSteps];
    const loggerFactory = new logger_factory_1.BaseLoggerFactory(config.isVerbose, logStream);
    const tracerFactory = (0, tracer_1.createTracerFactory)(lockedData);
    const motia = {
        loggerFactory,
        eventAdapter: adapters.eventAdapter,
        state,
        lockedData,
        printer,
        tracerFactory,
        app,
        stateAdapter: state,
    };
    const cronManager = (0, cron_handler_1.setupCronHandlers)(motia, adapters?.cronAdapter);
    const motiaEventManager = (0, step_handlers_1.createStepHandlers)(motia, adapters.eventAdapter);
    const asyncHandler = (step) => {
        return async (req, res) => {
            const traceId = (0, generate_trace_id_1.generateTraceId)();
            const { name: stepName, flows } = step.config;
            const logger = loggerFactory.create({ traceId, flows, stepName });
            logger.debug('[API] Received request, processing step', { path: req.path });
            const data = {
                body: req.body,
                headers: req.headers,
                pathParams: req.params,
                queryParams: req.query,
            };
            try {
                let result;
                if ('handler' in step && typeof step.handler === 'function') {
                    const context = {
                        traceId,
                        flows,
                        state: state,
                        emit: async (event) => {
                            const eventObj = {
                                ...event,
                                traceId,
                                flows,
                                logger,
                                tracer: null,
                            };
                            await adapters.eventAdapter.emit(eventObj);
                        },
                        logger,
                        streams: lockedData.getStreams(),
                    };
                    result = await step.handler(data, context);
                }
                else {
                    const tracer = await motia.tracerFactory.createTracer(traceId, step, logger);
                    result = await (0, call_step_file_1.callStepFile)({ data, step, logger, tracer, traceId }, motia);
                }
                (0, utils_1.trackEvent)('api_call_success', { stepName });
                if (!result) {
                    console.log('no result');
                    res.status(500).json({ error: 'Internal server error' });
                    return;
                }
                if (result.headers) {
                    Object.entries(result.headers).forEach(([key, value]) => res.setHeader(key, value));
                }
                res.status(result.status);
                // Handle different body types
                if (Buffer.isBuffer(result.body) || typeof result.body === 'string') {
                    res.send(result.body);
                }
                else {
                    res.json(result.body);
                }
            }
            catch (error) {
                (0, utils_1.trackEvent)('api_call_error', {
                    stepName,
                    traceId,
                    error: error instanceof Error ? error.message : 'Unknown error',
                });
                logger.error('[API] Internal server error', { error });
                console.log(error);
                res.status(500).json({ error: 'Internal server error' });
            }
        };
    };
    app.use(body_parser_1.default.json({ limit: '1gb' }));
    app.use(body_parser_1.default.urlencoded({ extended: true, limit: '1gb' }));
    const router = express_1.default.Router();
    const addRoute = (step) => {
        const { method, path } = step.config;
        logger_1.globalLogger.debug('[API] Registering route', step.config);
        const handler = asyncHandler(step);
        const methods = {
            GET: () => router.get(path, handler),
            POST: () => router.post(path, handler),
            PUT: () => router.put(path, handler),
            DELETE: () => router.delete(path, handler),
            PATCH: () => router.patch(path, handler),
            OPTIONS: () => router.options(path, handler),
            HEAD: () => router.head(path, handler),
        };
        const methodHandler = methods[method];
        if (!methodHandler) {
            throw new Error(`Unsupported method: ${method}`);
        }
        methodHandler();
    };
    const removeRoute = (step) => {
        const { path, method } = step.config;
        const routerStack = router.stack;
        const filteredStack = routerStack.filter((layer) => {
            if (layer.route) {
                const match = layer.route.path === path && layer.route.methods[method.toLowerCase()];
                return !match;
            }
            return true;
        });
        router.stack = filteredStack;
    };
    allSteps.filter(guards_1.isApiStep).forEach(addRoute);
    app.options('*', (_req, res) => {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', '*');
        res.header('Access-Control-Allow-Headers', '*');
        res.header('Access-Control-Max-Age', '600');
        res.header('Access-Control-Allow-Credentials', 'true');
        res.header('Access-Control-Allow-Private-Network', 'true');
        res.status(204).end();
    });
    app.use((_req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', '*');
        res.header('Access-Control-Allow-Headers', '*');
        res.header('Access-Control-Max-Age', '600');
        res.header('Access-Control-Allow-Credentials', 'true');
        res.header('Access-Control-Allow-Private-Network', 'true');
        next();
    });
    app.use(router);
    (0, flows_endpoint_1.flowsEndpoint)(lockedData);
    (0, flows_config_endpoint_1.flowsConfigEndpoint)(app, process.cwd(), lockedData);
    (0, analytics_endpoint_1.analyticsEndpoint)(app, process.cwd());
    (0, step_endpoint_1.stepEndpoint)(app, lockedData);
    server.on('error', (error) => {
        console.error('Server error:', error);
    });
    const close = async () => {
        await cronManager.close();
        socketServer.close();
        if (adapters?.eventAdapter) {
            await adapters.eventAdapter.shutdown();
        }
    };
    return { app, server, socketServer, close, removeRoute, addRoute, cronManager, motiaEventManager, motia, printer };
};
exports.createServer = createServer;
