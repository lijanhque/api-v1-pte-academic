"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStepHandlers = void 0;
const call_step_file_1 = require("./call-step-file");
const defaults_1 = require("./infrastructure-validator/defaults");
const validations_1 = require("./infrastructure-validator/validations");
const logger_1 = require("./logger");
const validate_event_input_1 = require("./validate-event-input");
const createStepHandlers = (motia, eventAdapter) => {
    const eventSteps = motia.lockedData.eventSteps();
    const handlerMap = new Map();
    logger_1.globalLogger.debug(`[step handler] creating step handlers for ${eventSteps.length} steps`);
    const removeLogger = (event) => {
        const { logger, tracer, ...rest } = event;
        return rest;
    };
    const createHandler = (step) => {
        const { config, filePath } = step;
        const { subscribes, name } = config;
        logger_1.globalLogger.debug('[step handler] establishing step subscriptions', { filePath, step: step.config.name });
        // âœ… Validate infrastructure config if present
        if (config.infrastructure) {
            logger_1.globalLogger.debug('[step handler] validating infrastructure config', {
                step: name,
                infrastructure: config.infrastructure,
            });
            const validationResult = (0, validations_1.validateInfrastructureConfig)(config.infrastructure);
            if (!validationResult.success && validationResult.errors) {
                logger_1.globalLogger.error('[step handler] Infrastructure configuration validation failed', {
                    step: name,
                    filePath,
                    errors: validationResult.errors,
                });
                return;
            }
            logger_1.globalLogger.debug('[step handler] infrastructure config validated successfully', { step: name });
        }
        const queueConfig = (0, defaults_1.getQueueConfigWithDefaults)(config.infrastructure);
        const handlers = [];
        subscribes.forEach(async (subscribe) => {
            const handler = async (event) => {
                const { data, traceId, flows } = event;
                const logger = event.logger
                    ? event.logger.child({ step: step.config.name })
                    : motia.loggerFactory.create({ traceId, flows: flows || [], stepName: step.config.name });
                const tracer = event.tracer
                    ? event.tracer.child(step, logger)
                    : await motia.tracerFactory.attachToTrace(traceId, step, logger);
                logger_1.globalLogger.debug('[step handler] received event', { event: removeLogger(event), step: name });
                (0, validate_event_input_1.validateEventInput)(step, event, motia);
                // Continue execution even if validation failed
                await (0, call_step_file_1.callStepFile)({ step, data, traceId, tracer, logger, infrastructure: config.infrastructure }, motia);
            };
            const subscriptionHandle = await eventAdapter.subscribe(subscribe, name, handler, queueConfig);
            handlers.push(subscriptionHandle);
        });
        handlerMap.set(filePath, handlers);
    };
    const removeHandler = (step) => {
        const { filePath } = step;
        const handlers = handlerMap.get(filePath);
        if (handlers) {
            handlers.forEach((subscriptionHandle) => {
                eventAdapter.unsubscribe(subscriptionHandle);
                logger_1.globalLogger.debug('[step handler] unsubscribed handler', {
                    filePath,
                    ...subscriptionHandle,
                    step: step.config.name,
                });
            });
            handlerMap.delete(filePath);
        }
    };
    eventSteps.forEach(createHandler);
    return { removeHandler, createHandler };
};
exports.createStepHandlers = createStepHandlers;
