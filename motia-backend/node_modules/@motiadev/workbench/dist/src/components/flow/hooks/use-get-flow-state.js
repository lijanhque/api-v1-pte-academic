import { useEdgesState, useNodesState } from '@xyflow/react';
import isEqual from 'fast-deep-equal';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { ApiFlowNode } from '../nodes/api-flow-node';
import { CronFlowNode } from '../nodes/cron-flow-node';
import { EventFlowNode } from '../nodes/event-flow-node';
import { NoopFlowNode } from '../nodes/noop-flow-node';
import { useSaveWorkflowConfig } from './use-save-workflow-config';
const DEFAULT_CONFIG = { x: 0, y: 0 };
const getNodePosition = (flowConfig, stepName) => {
    return flowConfig?.config[stepName] || DEFAULT_CONFIG;
};
const nodeComponentCache = new Map();
const BASE_NODE_TYPES = {
    event: EventFlowNode,
    api: ApiFlowNode,
    noop: NoopFlowNode,
    cron: CronFlowNode,
};
async function importFlow(flow, flowConfig) {
    const nodeTypes = { ...BASE_NODE_TYPES };
    const customNodePromises = flow.steps
        .filter((step) => step.nodeComponentPath)
        .map(async (step) => {
        const path = step.nodeComponentPath;
        // Check cache first
        if (nodeComponentCache.has(path)) {
            nodeTypes[path] = nodeComponentCache.get(path);
            return;
        }
        try {
            const module = await import(/* @vite-ignore */ `/@fs/${path}`);
            const component = module.Node ?? module.default;
            nodeComponentCache.set(path, component);
            nodeTypes[path] = component;
        }
        catch (error) {
            console.error(`Failed to load custom node component: ${path}`, error);
        }
    });
    await Promise.all(customNodePromises);
    const nodes = flow.steps.map((step) => ({
        id: step.id,
        type: step.nodeComponentPath || step.type,
        filePath: step.filePath,
        position: step.filePath ? getNodePosition(flowConfig, step.filePath) : DEFAULT_CONFIG,
        data: { ...step, nodeConfig: step.filePath ? getNodePosition(flowConfig, step.filePath) : DEFAULT_CONFIG },
        language: step.language,
    }));
    const edges = flow.edges.map((edge) => ({
        ...edge,
        type: 'base',
    }));
    return { nodes, edges, nodeTypes };
}
export const useGetFlowState = (flow, flowConfig) => {
    const [nodeTypes, setNodeTypes] = useState(BASE_NODE_TYPES);
    const [nodes, setNodes, onNodesChange] = useNodesState([]);
    const [edges, setEdges, onEdgesChange] = useEdgesState([]);
    const saveConfig = useSaveWorkflowConfig();
    const flowIdRef = useRef('');
    const saveTimeoutRef = useRef(null);
    const lastSavedConfigRef = useRef(null);
    const lastSavedFlowRef = useRef(null);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const memoizedFlowConfig = useMemo(() => flowConfig, [flowConfig?.id, flowConfig?.config]);
    useEffect(() => {
        if (!flow || flow.error)
            return;
        const hasSameConfig = isEqual(lastSavedConfigRef.current, memoizedFlowConfig?.config);
        const hasSameFlow = isEqual(lastSavedFlowRef.current, flow);
        if (hasSameConfig && hasSameFlow)
            return;
        lastSavedConfigRef.current = memoizedFlowConfig?.config;
        flowIdRef.current = flow.id;
        lastSavedFlowRef.current = flow;
        const importFlowAsync = async () => {
            try {
                const { nodes, edges, nodeTypes } = await importFlow(flow, flowConfig);
                setNodes(nodes);
                setEdges(edges);
                setNodeTypes(nodeTypes);
            }
            catch (error) {
                console.error('Failed to import flow:', error);
            }
        };
        importFlowAsync();
    }, [flow, memoizedFlowConfig, setNodes, setEdges, flowConfig]);
    const saveFlowConfig = useCallback((nodesToSave) => {
        if (saveTimeoutRef.current) {
            clearTimeout(saveTimeoutRef.current);
        }
        saveTimeoutRef.current = setTimeout(async () => {
            const steps = nodesToSave.reduce((acc, node) => {
                if (node.data.filePath) {
                    acc[node.data.filePath] = {
                        x: Math.round(node.position.x),
                        y: Math.round(node.position.y),
                    };
                    if (node.data.nodeConfig?.sourceHandlePosition) {
                        acc[node.data.filePath].sourceHandlePosition = node.data.nodeConfig.sourceHandlePosition;
                    }
                    if (node.data.nodeConfig?.targetHandlePosition) {
                        acc[node.data.filePath].targetHandlePosition = node.data.nodeConfig.targetHandlePosition;
                    }
                }
                return acc;
            }, {});
            if (!isEqual(steps, lastSavedConfigRef.current)) {
                lastSavedConfigRef.current = steps;
                const newConfig = { id: flowIdRef.current, config: steps };
                try {
                    await saveConfig(newConfig);
                }
                catch (error) {
                    console.error('Failed to save flow config:', error);
                }
            }
        }, 300);
    }, [saveConfig]);
    useEffect(() => {
        if (nodes.length > 0) {
            saveFlowConfig(nodes);
        }
        return () => {
            if (saveTimeoutRef.current) {
                clearTimeout(saveTimeoutRef.current);
            }
        };
    }, [nodes, saveFlowConfig]);
    return useMemo(() => ({ nodes, edges, onNodesChange, onEdgesChange, nodeTypes }), [nodes, edges, onNodesChange, onEdgesChange, nodeTypes]);
};
