"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConfigFile = isConfigFile;
exports.shouldInvalidatePlugins = shouldInvalidatePlugins;
exports.handlePluginHotUpdate = handlePluginHotUpdate;
const path_1 = __importDefault(require("path"));
const resolver_1 = require("./resolver");
const types_1 = require("./types");
const utils_1 = require("./utils");
const WATCHED_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.css', '.scss', '.less'];
function isConfigFile(file) {
    const normalizedFile = (0, utils_1.normalizePath)(file);
    return normalizedFile.endsWith('motia.config.ts') || normalizedFile.endsWith('motia.config.js');
}
/**
 * Checks if a file change should trigger HMR for plugins.
 *
 * @param file - The file path that changed
 * @param plugins - Current plugin configurations
 * @returns True if the change affects plugins
 */
function shouldInvalidatePlugins(file, plugins) {
    const normalizedFile = (0, utils_1.normalizePath)(file);
    const absoluteFile = path_1.default.isAbsolute(normalizedFile) ? normalizedFile : path_1.default.resolve(process.cwd(), normalizedFile);
    if (isConfigFile(file)) {
        return true;
    }
    const hasWatchedExtension = WATCHED_EXTENSIONS.some((ext) => absoluteFile.endsWith(ext));
    if (!hasWatchedExtension) {
        return false;
    }
    for (const plugin of plugins) {
        if ((0, utils_1.isLocalPlugin)(plugin.packageName)) {
            const resolved = (0, resolver_1.resolvePluginPackage)(plugin);
            const pluginAbsolutePath = path_1.default.isAbsolute(resolved.resolvedPath)
                ? resolved.resolvedPath
                : path_1.default.resolve(process.cwd(), resolved.resolvedPath);
            const normalizedPluginPath = pluginAbsolutePath.endsWith(path_1.default.sep)
                ? pluginAbsolutePath
                : `${pluginAbsolutePath}${path_1.default.sep}`;
            if (absoluteFile.startsWith(normalizedPluginPath) || absoluteFile === pluginAbsolutePath) {
                return true;
            }
        }
    }
    return false;
}
/**
 * Handles hot updates for the plugin system.
 * This function is called by Vite's handleHotUpdate hook.
 *
 * @param ctx - Vite's HMR context
 * @param plugins - Current plugin configurations
 * @param printer - Printer instance for logging
 * @returns Array of modules to update, or undefined to continue with default behavior
 */
function handlePluginHotUpdate(ctx, plugins, printer) {
    const { file, server, timestamp } = ctx;
    printer.printPluginLog(`HMR: File changed: ${(0, utils_1.normalizePath)(file)}`);
    if (isConfigFile(file)) {
        printer.printPluginLog('HMR: Config file changed, triggering full page reload');
        printer.printPluginWarn('Configuration changes require a server restart for full effect. Please restart the dev server to apply all changes.');
        server.ws.send({
            type: 'full-reload',
            path: '*',
        });
        return;
    }
    if (!shouldInvalidatePlugins(file, plugins)) {
        printer.printPluginLog('HMR: Change outside plugin scope, delegating to Vite default handling');
        return;
    }
    printer.printPluginLog('HMR: Plugin change detected, invalidating virtual module');
    const virtualModule = server.moduleGraph.getModuleById(types_1.CONSTANTS.RESOLVED_VIRTUAL_MODULE_ID);
    if (!virtualModule) {
        printer.printPluginWarn('HMR: Virtual module not found, triggering full reload as fallback');
        server.ws.send({
            type: 'full-reload',
            path: '*',
        });
        return;
    }
    server.moduleGraph.invalidateModule(virtualModule, new Set(), timestamp);
    printer.printPluginLog('HMR: Virtual module invalidated');
    const modulesToUpdateSet = new Set([virtualModule]);
    const processedModules = new Set([virtualModule]);
    for (const importer of virtualModule.importers) {
        if (!processedModules.has(importer)) {
            processedModules.add(importer);
            modulesToUpdateSet.add(importer);
            server.moduleGraph.invalidateModule(importer, new Set(), timestamp);
        }
    }
    const modulesToUpdate = Array.from(modulesToUpdateSet);
    printer.printPluginLog(`HMR: Updated ${modulesToUpdate.length} module(s)`);
    return modulesToUpdate;
}
