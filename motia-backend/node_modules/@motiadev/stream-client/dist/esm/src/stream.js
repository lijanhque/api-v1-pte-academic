import { v4 as uuidv4 } from 'uuid';
import { StreamGroupSubscription } from './stream-group';
import { StreamItemSubscription } from './stream-item';
export class Stream {
    constructor(adapterFactory) {
        this.adapterFactory = adapterFactory;
        this.listeners = {};
        this.ws = this.createSocket();
    }
    createSocket() {
        this.ws = this.adapterFactory();
        this.ws.onMessage((message) => this.messageListener(message));
        this.ws.onOpen(() => this.onSocketOpen());
        this.ws.onClose(() => this.onSocketClose());
        return this.ws;
    }
    /**
     * Subscribe to an item in a stream.
     *
     * @argument streamName - The name of the stream to subscribe to.
     * @argument groupId - The id of the group to subscribe to.
     * @argument id - The id of the item to subscribe to.
     */
    subscribeItem(streamName, groupId, id) {
        const subscriptionId = uuidv4();
        const sub = { streamName, groupId, id, subscriptionId };
        const subscription = new StreamItemSubscription(sub);
        this.subscribe(subscription);
        return subscription;
    }
    /**
     * Subscribe to a group in a stream.
     *
     * @argument streamName - The name of the stream to subscribe to.
     * @argument groupId - The id of the group to subscribe to.
     */
    subscribeGroup(streamName, groupId, sortKey) {
        const subscriptionId = uuidv4();
        const sub = { streamName, groupId, subscriptionId };
        const subscription = new StreamGroupSubscription(sub, sortKey);
        this.subscribe(subscription);
        return subscription;
    }
    close() {
        this.listeners = {}; // clean up all listeners
        this.ws.close();
    }
    onSocketClose() {
        // retry to connect
        setTimeout(() => this.createSocket(), 2000);
    }
    onSocketOpen() {
        Object.values(this.listeners).forEach((listeners) => {
            listeners.forEach((subscription) => this.join(subscription));
        });
    }
    messageListener(event) {
        const message = JSON.parse(event);
        const room = this.roomName(message);
        this.listeners[room]?.forEach((listener) => listener.listener(message));
        // we need to discard sync to group subs when it's an item event
        if (message.id && message.event.type !== 'sync') {
            const groupRoom = this.roomName({
                streamName: message.streamName,
                groupId: message.groupId,
            });
            this.listeners[groupRoom]?.forEach((listener) => listener.listener(message));
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subscribe(subscription) {
        const room = this.roomName(subscription.sub);
        if (!this.listeners[room]) {
            this.listeners[room] = new Set();
        }
        this.listeners[room].add(subscription);
        this.join(subscription);
        subscription.onClose(() => {
            this.listeners[room]?.delete(subscription);
            this.leave(subscription);
        });
    }
    join(subscription) {
        if (this.ws.isOpen()) {
            this.ws.send(JSON.stringify({ type: 'join', data: subscription.sub }));
        }
    }
    leave(subscription) {
        if (this.ws.isOpen()) {
            this.ws.send(JSON.stringify({ type: 'leave', data: subscription.sub }));
        }
    }
    roomName(message) {
        return message.id
            ? `${message.streamName}:group:${message.groupId}:item:${message.id}`
            : `${message.streamName}:group:${message.groupId}`;
    }
}
