"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTemplate = generateTemplate;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
/**
 * Reads a template file and replaces variables
 */
async function readTemplate(templatePath, answers) {
    const content = await fs_1.promises.readFile(templatePath, 'utf8');
    return replaceTemplateVariables(content, answers);
}
/**
 * Replaces template variables with actual values
 */
function replaceTemplateVariables(content, answers) {
    const replacements = {
        STEP_NAME: answers.name,
        DESCRIPTION: answers.description || '',
        FLOWS: JSON.stringify(answers.flows),
        EMITS: JSON.stringify(answers.emits),
        METHOD: answers.method || '',
        PATH: answers.path || '',
        SUBSCRIPTIONS: JSON.stringify(answers.subscriptions || []),
        CRON_EXPRESSION: answers.cronExpression || '',
        VIRTUAL_EMITS: JSON.stringify(answers.virtualEmits || []),
        VIRTUAL_SUBSCRIBES: JSON.stringify(answers.virtualSubscribes || []),
    };
    return Object.entries(replacements).reduce((content, [key, value]) => {
        const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
        return content.replace(regex, String(value));
    }, content);
}
/**
 * Generates the appropriate template based on language and type
 */
async function generateTemplate(answers) {
    const templateDir = path_1.default.join(__dirname, 'templates', answers.type);
    const templateFile = `template.${answers.language}.txt`;
    const templatePath = path_1.default.join(templateDir, templateFile);
    try {
        return await readTemplate(templatePath, answers);
    }
    catch (error) {
        throw new Error(`Failed to generate template: ${error}`);
    }
}
