"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateLockedData = exports.collectFlows = exports.getStreamFiles = exports.getStepFiles = void 0;
const core_1 = require("@motiadev/core");
const printer_1 = require("@motiadev/core/dist/src/printer");
const colors_1 = __importDefault(require("colors"));
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const glob_1 = require("glob");
const path_1 = __importDefault(require("path"));
const activate_python_env_1 = require("./utils/activate-python-env");
const compilation_error_1 = require("./utils/errors/compilation.error");
const locked_data_generation_error_1 = require("./utils/errors/locked-data-generation.error");
const version = `${(0, crypto_1.randomUUID)()}:${Math.floor(Date.now() / 1000)}`;
const getStepFilesFromDir = (dir) => {
    if (!(0, fs_1.existsSync)(dir)) {
        return [];
    }
    return [
        ...(0, glob_1.globSync)('**/*.step.{ts,js,rb}', { absolute: true, cwd: dir }),
        ...(0, glob_1.globSync)('**/*_step.{ts,js,py,rb}', { absolute: true, cwd: dir }),
    ];
};
const getStepFiles = (projectDir) => {
    const stepsDir = path_1.default.join(projectDir, 'steps');
    const srcDir = path_1.default.join(projectDir, 'src');
    return [...getStepFilesFromDir(stepsDir), ...getStepFilesFromDir(srcDir)];
};
exports.getStepFiles = getStepFiles;
const getStreamFilesFromDir = (dir) => {
    if (!(0, fs_1.existsSync)(dir)) {
        return [];
    }
    return [
        ...(0, glob_1.globSync)('**/*.stream.{ts,js,rb}', { absolute: true, cwd: dir }),
        ...(0, glob_1.globSync)('**/*_stream.{ts,js,py,rb}', { absolute: true, cwd: dir }),
    ];
};
const getStreamFiles = (projectDir) => {
    const stepsDir = path_1.default.join(projectDir, 'steps');
    const srcDir = path_1.default.join(projectDir, 'src');
    return [...getStreamFilesFromDir(stepsDir), ...getStreamFilesFromDir(srcDir)];
};
exports.getStreamFiles = getStreamFiles;
// Helper function to recursively collect flow data
const collectFlows = async (projectDir, lockedData) => {
    const invalidSteps = [];
    const stepFiles = (0, exports.getStepFiles)(projectDir);
    const streamFiles = (0, exports.getStreamFiles)(projectDir);
    const stepsDir = path_1.default.join(projectDir, 'steps');
    const srcDir = path_1.default.join(projectDir, 'src');
    const deprecatedSteps = [
        ...((0, fs_1.existsSync)(stepsDir) ? (0, glob_1.globSync)('**/*.step.py', { absolute: true, cwd: stepsDir }) : []),
        ...((0, fs_1.existsSync)(srcDir) ? (0, glob_1.globSync)('**/*.step.py', { absolute: true, cwd: srcDir }) : []),
    ];
    const hasPythonFiles = stepFiles.some((file) => file.endsWith('.py'));
    if (hasPythonFiles) {
        (0, activate_python_env_1.activatePythonVenv)({ baseDir: projectDir });
    }
    for (const filePath of stepFiles) {
        try {
            const config = await (0, core_1.getStepConfig)(filePath, projectDir);
            if (!config) {
                console.warn(`No config found in step ${filePath}, step skipped`);
                continue;
            }
            const result = lockedData.createStep({ filePath, version, config }, { disableTypeCreation: true });
            if (!result) {
                invalidSteps.push({ filePath, version, config });
            }
        }
        catch (err) {
            throw new compilation_error_1.CompilationError(`Error collecting flow ${filePath}`, path_1.default.relative(projectDir, filePath), err);
        }
    }
    for (const filePath of streamFiles) {
        const config = await (0, core_1.getStreamConfig)(filePath);
        if (!config) {
            console.warn(`No config found in stream ${filePath}, stream skipped`);
            continue;
        }
        lockedData.createStream({ filePath, config }, { disableTypeCreation: true });
    }
    if (deprecatedSteps.length > 0) {
        const warning = colors_1.default.yellow('! [WARNING]');
        console.warn(colors_1.default.yellow([
            '',
            '========================================',
            warning,
            '',
            `Python steps with ${colors_1.default.gray('.step.py')} extensions are no longer supported.`,
            `Please rename them to ${colors_1.default.gray('_step.py')}.`,
            '',
            colors_1.default.bold('Steps:'),
            ...deprecatedSteps.map((step) => colors_1.default.reset(`- ${colors_1.default.cyan(colors_1.default.bold(step.replace(projectDir, '')))} rename to ${colors_1.default.gray(`${step.replace(projectDir, '').replace('.step.py', '_step.py')}`)}`)),
            '',
            'Make sure the step names are importable from Python:',
            `- Don't use numbers, dots, dashes, commas, spaces, colons, or special characters`,
            '========================================',
            '',
        ].join('\n')));
    }
    return invalidSteps;
};
exports.collectFlows = collectFlows;
const generateLockedData = async (config) => {
    try {
        const { projectDir, streamAdapter, printerType = 'default', redisClient } = config;
        const printer = printerType === 'disabled' ? new printer_1.NoPrinter() : new printer_1.Printer(projectDir);
        /*
         * NOTE: right now for performance and simplicity let's enforce a folder,
         * but we might want to remove this and scan the entire current directory
         */
        const lockedData = new core_1.LockedData(projectDir, streamAdapter, printer, redisClient);
        await (0, exports.collectFlows)(projectDir, lockedData);
        lockedData.saveTypes();
        return lockedData;
    }
    catch (error) {
        console.error(error);
        throw new locked_data_generation_error_1.LockedDataGenerationError('Failed to parse the project, generating locked data step failed', error);
    }
};
exports.generateLockedData = generateLockedData;
