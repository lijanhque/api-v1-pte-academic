"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedisTestHelper = void 0;
exports.createMockRedisClient = createMockRedisClient;
exports.resetMockRedisClient = resetMockRedisClient;
exports.setupRedisTestHelper = setupRedisTestHelper;
function createMockRedisClient(options = {}) {
    const { autoConnect = true, isOpen = true } = options;
    const mockClient = {
        connect: jest.fn().mockResolvedValue(undefined),
        quit: jest.fn().mockResolvedValue(undefined),
        disconnect: jest.fn().mockResolvedValue(undefined),
        isOpen,
        on: jest.fn(),
        get: jest.fn().mockResolvedValue(null),
        set: jest.fn().mockResolvedValue('OK'),
        del: jest.fn().mockResolvedValue(1),
        exists: jest.fn().mockResolvedValue(1),
        keys: jest.fn().mockResolvedValue([]),
        flushAll: jest.fn().mockResolvedValue('OK'),
        ping: jest.fn().mockResolvedValue('PONG'),
        xAdd: jest.fn().mockResolvedValue(''),
        xRead: jest.fn().mockResolvedValue([]),
        xReadGroup: jest.fn().mockResolvedValue([]),
        xGroupCreate: jest.fn().mockResolvedValue('OK'),
        xAck: jest.fn().mockResolvedValue(1),
        hGet: jest.fn().mockResolvedValue(null),
        hSet: jest.fn().mockResolvedValue(1),
        hGetAll: jest.fn().mockResolvedValue({}),
        hDel: jest.fn().mockResolvedValue(1),
        hExists: jest.fn().mockResolvedValue(0),
        expire: jest.fn().mockResolvedValue(1),
        ttl: jest.fn().mockResolvedValue(-1),
        publish: jest.fn().mockResolvedValue(0),
    };
    if (autoConnect) {
        mockClient.connect.mockResolvedValue(undefined);
    }
    return mockClient;
}
function resetMockRedisClient(client) {
    Object.keys(client).forEach((key) => {
        if (jest.isMockFunction(client[key])) {
            client[key].mockClear();
        }
    });
}
function setupRedisTestHelper() {
    const mockClient = createMockRedisClient();
    return {
        mockClient,
        reset: () => resetMockRedisClient(mockClient),
    };
}
class RedisTestHelper {
    constructor(options = {}) {
        this.client = createMockRedisClient(options);
    }
    getClient() {
        return this.client;
    }
    reset() {
        resetMockRedisClient(this.client);
    }
    mockGet(key, value) {
        this.client.get.mockImplementation((k) => {
            if (k === key) {
                return Promise.resolve(value);
            }
            return Promise.resolve(null);
        });
    }
    mockSet(_key, _value) {
        this.client.set.mockResolvedValue('OK');
    }
    mockExists(key, exists) {
        this.client.exists.mockImplementation((k) => {
            if (k === key) {
                return Promise.resolve(exists ? 1 : 0);
            }
            return Promise.resolve(0);
        });
    }
    mockKeys(_pattern, keys) {
        this.client.keys.mockResolvedValue(keys);
    }
    mockConnectError(error) {
        this.client.connect.mockRejectedValue(error);
    }
    mockQuitError(error) {
        this.client.quit.mockRejectedValue(error);
    }
    setConnectionState(isOpen) {
        Object.defineProperty(this.client, 'isOpen', {
            value: isOpen,
            writable: true,
            configurable: true,
        });
    }
}
exports.RedisTestHelper = RedisTestHelper;
