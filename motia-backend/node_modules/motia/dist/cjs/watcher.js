"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Watcher = void 0;
const core_1 = require("@motiadev/core");
const chokidar_1 = __importDefault(require("chokidar"));
const crypto_1 = require("crypto");
class Watcher {
    constructor(dir, lockedData) {
        this.dir = dir;
        this.lockedData = lockedData;
    }
    onStepChange(handler) {
        this.stepChangeHandler = handler;
    }
    onStepCreate(handler) {
        this.stepCreateHandler = handler;
    }
    onStepDelete(handler) {
        this.stepDeleteHandler = handler;
    }
    onStreamChange(handler) {
        this.streamChangeHandler = handler;
    }
    onStreamCreate(handler) {
        this.streamCreateHandler = handler;
    }
    onStreamDelete(handler) {
        this.streamDeleteHandler = handler;
    }
    findStep(path) {
        return (this.lockedData.activeSteps.find((step) => step.filePath === path) ||
            this.lockedData.devSteps.find((step) => step.filePath === path));
    }
    async onStepFileAdd(path) {
        if (!this.stepCreateHandler) {
            console.warn(`No step create handler, step skipped`);
            return;
        }
        const config = await (0, core_1.getStepConfig)(path, this.dir).catch((err) => console.error(err));
        if (!config) {
            return;
        }
        const version = `${(0, crypto_1.randomUUID)()}:${Math.floor(Date.now() / 1000)}`;
        const step = { filePath: path, version, config };
        this.stepCreateHandler?.(step);
    }
    async onStepFileChange(path) {
        const config = await (0, core_1.getStepConfig)(path, this.dir).catch((err) => {
            console.error(err);
        });
        const step = this.findStep(path);
        if (!step && !config) {
            return;
        }
        // didn't have a step, but now we have a config
        if (!step && config) {
            const version = `${(0, crypto_1.randomUUID)()}:${Math.floor(Date.now() / 1000)}`;
            const step = { filePath: path, version, config };
            this.stepCreateHandler?.(step);
        }
        // had a step, and now we have a config
        if (step && config) {
            const newStep = { ...step, config };
            this.stepChangeHandler?.(step, newStep);
        }
        // had a step, but no config
        if (step && !config) {
            this.stepDeleteHandler?.(step);
        }
    }
    async onStepFileDelete(path) {
        const step = this.findStep(path);
        if (!step) {
            console.warn(`Step ${path} not found, step skipped`);
            return;
        }
        this.stepDeleteHandler?.(step);
    }
    async onStreamFileAdd(path) {
        const config = await (0, core_1.getStreamConfig)(path).catch((err) => console.error(err));
        if (!config) {
            return;
        }
        this.streamCreateHandler?.({ filePath: path, config, factory: null });
    }
    async onStreamFileChange(path) {
        const stream = this.lockedData.findStream(path);
        const config = await (0, core_1.getStreamConfig)(path).catch((err) => console.error(err));
        if (!stream && config) {
            this.streamCreateHandler?.({ filePath: path, config, factory: null });
        }
        else if (stream && config) {
            this.streamChangeHandler?.(stream, { filePath: path, config, factory: null });
        }
        else if (stream && !config) {
            this.streamDeleteHandler?.(stream);
        }
    }
    async onStreamFileDelete(path) {
        const stream = this.lockedData.findStream(path);
        if (this.streamDeleteHandler && stream) {
            this.streamDeleteHandler(stream);
        }
    }
    async onFileAdd(path) {
        if (this.isStepFile(path)) {
            this.onStepFileAdd(path);
        }
        else if (this.isStreamFile(path)) {
            this.onStreamFileAdd(path);
        }
    }
    async onFileChange(path) {
        if (this.isStepFile(path)) {
            this.onStepFileChange(path);
        }
        else if (this.isStreamFile(path)) {
            this.onStreamFileChange(path);
        }
    }
    async onFileDelete(path) {
        if (this.isStepFile(path)) {
            this.onStepFileDelete(path);
        }
        else if (this.isStreamFile(path)) {
            this.onStreamFileDelete(path);
        }
    }
    init() {
        this.watcher = chokidar_1.default
            .watch(this.dir, { persistent: true, ignoreInitial: true })
            .on('add', (path) => this.onFileAdd(path))
            .on('change', (path) => this.onFileChange(path))
            .on('unlink', (path) => this.onFileDelete(path));
    }
    isStepFile(path) {
        const isUiNode = /\.(tsx|jsx)$/.test(path);
        const isDeprecatedPythonStep = /\.step\.py$/.test(path);
        return /[._]step\.((ts)|(js)|(rb)|(py))$/.test(path) && !isUiNode && !isDeprecatedPythonStep;
    }
    isStreamFile(path) {
        const isUiNode = /\.(tsx|jsx)$/.test(path);
        const isDeprecatedPythonStream = /\.stream\.py$/.test(path);
        return /[._]stream\.((ts)|(js)|(rb)|(py))$/.test(path) && !isUiNode && !isDeprecatedPythonStream;
    }
    async stop() {
        if (this.watcher) {
            await this.watcher.close();
        }
    }
}
exports.Watcher = Watcher;
