"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stopRedisMemoryServer = exports.instanceRedisMemoryServer = void 0;
const fs_1 = require("fs");
const redis_1 = require("redis");
const redis_memory_server_1 = require("redis-memory-server");
class RedisMemoryManager {
    constructor() {
        this.server = null;
        this.client = null;
        this.running = false;
        this.cleanupHandlersRegistered = false;
    }
    registerCleanupHandlers() {
        if (this.cleanupHandlersRegistered)
            return;
        process.on('exit', () => {
            if (this.client?.isOpen && this.running) {
                this.client.quit().catch((error) => {
                    console.error('[Redis Memory Server] Error closing client on exit:', error);
                });
            }
            if (this.server && this.running) {
                this.server.stop().catch((error) => {
                    console.error('[Redis Memory Server] Error stopping on exit:', error);
                });
            }
        });
        process.on('SIGTERM', async () => {
            await this.stop();
        });
        process.on('SIGINT', async () => {
            await this.stop();
        });
        this.cleanupHandlersRegistered = true;
    }
    async start(baseDir, autoStart) {
        if (this.client && this.running) {
            return this.client;
        }
        try {
            (0, fs_1.mkdirSync)(baseDir, { recursive: true });
            const instance = {
                ip: process.env.MOTIA_REDIS_HOST || '127.0.0.1',
                args: ['--appendonly', 'yes', '--save', '900 1', '--save', '300 10', '--save', '60 100', '--dir', baseDir],
            };
            if (process.env.MOTIA_REDIS_PORT) {
                instance.port = parseInt(process.env.MOTIA_REDIS_PORT || '6379');
            }
            this.server = new redis_memory_server_1.RedisMemoryServer({
                instance,
                autoStart,
            });
            const host = await this.server.getHost();
            const port = await this.server.getPort();
            this.client = (0, redis_1.createClient)({
                socket: {
                    host,
                    port,
                    noDelay: true,
                    keepAlive: true,
                    reconnectStrategy: (retries) => {
                        if (retries > 10) {
                            return new Error('Redis connection retry limit exceeded');
                        }
                        return Math.min(retries * 100, 3000);
                    },
                    connectTimeout: 10000,
                },
            });
            this.client.on('error', (err) => {
                if (err.message.includes('ECONNRESET') || err.message.includes('ECONNREFUSED')) {
                    return;
                }
                console.error('[Redis Memory Server] Client error:', err);
            });
            await this.client.connect();
            this.running = true;
            this.registerCleanupHandlers();
            console.log(`[Redis Memory Server] Started on ${host}:${port}`);
            return this.client;
        }
        catch (error) {
            console.error('[Redis Memory Server] Failed to start:', error);
            throw error;
        }
    }
    async stop() {
        if (this.client && this.running) {
            try {
                if (this.client.isOpen) {
                    await this.client.quit().catch((error) => {
                        console.error('[Redis Memory Server] Error closing client:', error);
                    });
                }
                this.client = null;
            }
            catch (error) { }
        }
        if (this.server && this.running) {
            try {
                await this.server.stop();
                this.running = false;
            }
            catch (error) {
                console.error('[Redis Memory Server] Error stopping:', error);
            }
            finally {
                this.server = null;
            }
        }
    }
    isRunning() {
        return this.running;
    }
    getClient() {
        return this.client;
    }
}
const manager = new RedisMemoryManager();
const instanceRedisMemoryServer = (baseDir, autoStart = true) => manager.start(baseDir, autoStart);
exports.instanceRedisMemoryServer = instanceRedisMemoryServer;
const stopRedisMemoryServer = () => manager.stop();
exports.stopRedisMemoryServer = stopRedisMemoryServer;
