"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const core_1 = require("@motiadev/core");
const printer_1 = require("@motiadev/core/dist/src/printer");
const fs_1 = __importDefault(require("fs"));
const generate_locked_data_1 = require("../../generate-locked-data");
const redis_memory_manager_1 = require("../../redis-memory-manager");
const build_error_1 = require("../../utils/errors/build.error");
const builder_1 = require("../build/builder");
const node_1 = require("../build/builders/node");
const python_1 = require("../build/builders/python");
const constants_1 = require("./constants");
const hasPythonSteps = (stepFiles) => {
    return stepFiles.some((file) => file.endsWith('.py'));
};
const build = async (listener) => {
    const builder = new builder_1.Builder(constants_1.projectDir, listener);
    const stepFiles = (0, generate_locked_data_1.getStepFiles)(constants_1.projectDir);
    if (stepFiles.length === 0) {
        throw new Error('Project contains no steps, please add some steps before building');
    }
    // Register language-specific builders
    builder.registerBuilder('node', new node_1.NodeBuilder(builder, listener));
    fs_1.default.rmSync(constants_1.distDir, { recursive: true, force: true });
    fs_1.default.mkdirSync(constants_1.distDir, { recursive: true });
    const redisClient = await (0, redis_memory_manager_1.instanceRedisMemoryServer)(constants_1.projectDir, false);
    const lockedData = new core_1.LockedData(constants_1.projectDir, new core_1.MemoryStreamAdapterManager(), new printer_1.NoPrinter(), redisClient);
    if (hasPythonSteps(stepFiles)) {
        builder.registerBuilder('python', new python_1.PythonBuilder(builder, listener));
    }
    const invalidSteps = await (0, generate_locked_data_1.collectFlows)(constants_1.projectDir, lockedData).catch((err) => {
        const errorMessage = err.filePath ? `Build error in ${err.filePath}` : 'Build error';
        const finalMessage = `${errorMessage}\nPlease check the logs above for details`;
        throw new build_error_1.BuildError(build_error_1.BuildErrorType.COMPILATION, err.filePath, finalMessage, err);
    });
    if (invalidSteps.length > 0) {
        throw new Error('Project contains invalid steps, please fix them before building');
    }
    await Promise.all(lockedData.activeSteps.map((step) => builder.buildStep(step)));
    await builder.buildApiSteps(lockedData.activeSteps.filter(core_1.isApiStep));
    const streams = lockedData.listStreams();
    for (const stream of streams) {
        if (stream.config.baseConfig.storageType === 'default') {
            builder.registerStateStream(stream);
        }
        else {
            listener.onWarning(stream.filePath, 'Custom streams are not supported yet in the cloud');
        }
    }
    const stepsFile = {
        steps: builder.stepsConfig,
        streams: builder.streamsConfig,
        routers: builder.routersConfig,
    };
    fs_1.default.writeFileSync(constants_1.stepsConfigPath, JSON.stringify(stepsFile, null, 2));
    return builder;
};
exports.build = build;
