"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamingDeploymentListener = void 0;
const deployment_stream_1 = require("../streams/deployment-stream");
class StreamingDeploymentListener {
    constructor(deploymentId, deploymentStream) {
        this.deploymentId = deploymentId;
        this.errors = [];
        this.warnings = [];
        this.streamManager = new deployment_stream_1.DeploymentStreamManager(deploymentStream);
    }
    relativePath(path) {
        return path.replace(`${process.cwd()}/`, '');
    }
    getStepType(step) {
        if (step.config.type === 'api')
            return 'api';
        if (step.config.type === 'cron')
            return 'cron';
        return 'event';
    }
    getLanguage(filePath) {
        if (filePath.endsWith('.ts') || filePath.endsWith('.js'))
            return 'node';
        if (filePath.endsWith('.py'))
            return 'python';
        if (filePath.endsWith('.rb'))
            return 'ruby';
        return 'unknown';
    }
    async updateStream(update) {
        const current = await this.streamManager.getDeployment(this.deploymentId);
        if (!current) {
            return;
        }
        const mergedUpdate = {
            ...update,
        };
        await this.streamManager.updateDeployment(this.deploymentId, mergedUpdate);
    }
    getErrors() {
        return this.errors;
    }
    // Build phase events
    async onBuildStart(step) {
        const message = `Building step: ${step.config.name}`;
        const buildOutput = {
            packagePath: this.relativePath(step.filePath),
            language: this.getLanguage(step.filePath),
            status: 'building',
            type: this.getStepType(step),
        };
        await this.updateStream({
            phase: 'build',
            status: 'building',
            message,
        });
        await this.streamManager.updateBuildOutput(this.deploymentId, buildOutput);
    }
    async onBuildProgress(step, message) {
        const logMessage = `${step.config.name}: ${message}`;
        await this.updateStream({ message: logMessage });
    }
    async onBuildEnd(step, size) {
        const message = `Built ${step.config.name} (${size} bytes)`;
        const buildOutput = {
            packagePath: this.relativePath(step.filePath),
            language: this.getLanguage(step.filePath),
            status: 'built',
            type: this.getStepType(step),
            size,
        };
        await this.updateStream({ message });
        await this.streamManager.updateBuildOutput(this.deploymentId, buildOutput);
    }
    async onBuildError(step, error) {
        const message = `Error building ${step.config.name}: ${error.message}`;
        const buildOutput = {
            packagePath: this.relativePath(step.filePath),
            language: this.getLanguage(step.filePath),
            status: 'error',
            type: this.getStepType(step),
            errorMessage: error.message,
        };
        await this.updateStream({
            status: 'failed',
            message,
            error: error.message,
        });
        await this.streamManager.updateBuildOutput(this.deploymentId, buildOutput);
    }
    async onBuildSkip(step, reason) {
        const message = `Skipped ${step.config.name}: ${reason}`;
        await this.updateStream({ message });
    }
    async onStreamCreated(stream) {
        const message = `Created stream: ${stream.config.name}`;
        await this.updateStream({ message });
    }
    async onApiRouterBuilding(language) {
        const message = `Building API router for ${language}`;
        await this.updateStream({ message });
    }
    async onApiRouterBuilt(language, size) {
        const message = `Built API router for ${language} (${size} bytes)`;
        await this.updateStream({ message });
    }
    async onWarning(id, warning) {
        this.warnings.push({
            relativePath: id,
            message: warning,
            step: {},
        });
        await this.updateStream({
            message: `Warning: ${warning}`,
        });
    }
    async onBuildWarning(warning) {
        this.warnings.push(warning);
        await this.updateStream({
            message: `Build warning: ${warning.message}`,
        });
    }
    async onBuildErrors(errors) {
        this.errors.push(...errors);
        const errorMessage = `Build failed with ${errors.length} errors`;
        await this.updateStream({
            status: 'failed',
            message: errorMessage,
            error: errors.map((error) => error.message).join('\n'),
        });
    }
    // Upload phase events
    async stepUploadStart(stepPath, step) {
        const message = `Starting upload: ${step.config.name}`;
        const uploadOutput = {
            packagePath: this.relativePath(stepPath),
            language: this.getLanguage(step.filePath),
            status: 'uploading',
            type: step.config.type,
            progress: 0,
        };
        await this.updateStream({
            phase: 'upload',
            status: 'uploading',
            message,
        });
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    async stepUploadProgress(stepPath, step, progress) {
        const uploadOutput = {
            packagePath: stepPath,
            language: this.getLanguage(step.filePath),
            status: 'uploading',
            type: step.config.type,
            progress,
        };
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    async stepUploadEnd(stepPath, step) {
        const uploadOutput = {
            packagePath: this.relativePath(stepPath),
            language: this.getLanguage(step.filePath),
            status: 'uploaded',
            type: step.config.type,
            progress: 100,
        };
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    async stepUploadError(stepPath, step) {
        const message = `Upload failed: ${step.config.name}`;
        const uploadOutput = {
            packagePath: this.relativePath(stepPath),
            language: this.getLanguage(step.filePath),
            status: 'error',
            type: step.config.type,
            errorMessage: message,
        };
        await this.updateStream({
            status: 'failed',
            message,
            error: message,
        });
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    async routeUploadStart(path, language) {
        const uploadOutput = {
            packagePath: this.relativePath(path),
            language,
            status: 'uploading',
            type: 'api',
            progress: 0,
        };
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    async routeUploadProgress(path, language, progress) {
        const uploadOutput = {
            packagePath: this.relativePath(path),
            language,
            status: 'uploading',
            type: 'api',
            progress,
        };
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    async routeUploadEnd(path, language) {
        const message = `Uploaded: ${language} router`;
        const uploadOutput = {
            packagePath: this.relativePath(path),
            language,
            status: 'uploaded',
            type: 'api',
            progress: 100,
        };
        await this.updateStream({ message });
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    async routeUploadError(path, language) {
        const message = `Upload failed: ${language} router`;
        const uploadOutput = {
            packagePath: this.relativePath(path),
            language,
            status: 'error',
            type: 'api',
            errorMessage: message,
        };
        await this.updateStream({
            status: 'failed',
            message,
            error: message,
        });
        await this.streamManager.updateUploadOutput(this.deploymentId, uploadOutput);
    }
    // Deploy phase events
    async onDeployStart() {
        const message = 'Deployment started';
        await this.updateStream({
            phase: 'deploy',
            status: 'deploying',
            message,
        });
    }
    async onDeployProgress(data) {
        const message = `Deployment status: ${data.status}`;
        await this.updateStream({
            message,
        });
    }
    async onDeployEnd() {
        await this.streamManager.completeDeployment(this.deploymentId);
    }
    async onDeployError(errorMessage) {
        await this.streamManager.completeDeployment(this.deploymentId, errorMessage);
    }
    // Utility methods for phase management
    async startBuildPhase() {
        await this.updateStream({
            phase: 'build',
            status: 'building',
            message: 'Build phase started',
        });
    }
    async startUploadPhase() {
        await this.updateStream({
            phase: 'upload',
            status: 'uploading',
            message: 'Upload phase started',
        });
    }
    async startDeployPhase() {
        await this.updateStream({
            phase: 'deploy',
            status: 'deploying',
            message: 'Deploy phase started',
        });
    }
}
exports.StreamingDeploymentListener = StreamingDeploymentListener;
