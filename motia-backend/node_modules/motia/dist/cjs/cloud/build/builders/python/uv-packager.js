"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UvPackager = exports.defaultUvConfig = void 0;
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
exports.defaultUvConfig = {
    pythonVersion: process.env.MOTIA_PYTHON_VERSION || '3.13',
    platform: process.env.MOTIA_PLATFORM || 'x86_64-manylinux2014',
    onlyBinary: process.env.MOTIA_ONLY_BINARY !== 'false',
};
class UvPackager {
    constructor(config = exports.defaultUvConfig) {
        this.config = config;
    }
    async packageDependencies(cwd) {
        const requirementsFile = path_1.default.join(cwd, 'requirements.txt');
        const args = [
            'pip',
            'install',
            '--target',
            cwd,
            '--requirement',
            requirementsFile,
            '--python-version',
            this.config.pythonVersion || '3.13',
            '--python-platform',
            this.config.platform || 'x86_64-manylinux2014',
        ];
        if (this.config.onlyBinary) {
            args.push('--only-binary=:all:');
        }
        await this.runCommand('uv', args, { cwd });
    }
    async runCommand(command, args, options) {
        return new Promise((resolve, reject) => {
            const child = (0, child_process_1.spawn)(command, args, {
                cwd: options?.cwd,
                stdio: ['pipe', 'pipe', 'pipe'],
            });
            let stdout = '';
            let stderr = '';
            child.stdout?.on('data', (data) => {
                stdout += data.toString();
                if (options?.showOutput) {
                    process.stdout.write(data);
                }
            });
            child.stderr?.on('data', (data) => {
                stderr += data.toString();
            });
            child.on('close', (code) => {
                if (code === 0) {
                    resolve(stdout);
                }
                else {
                    const errorPrefix = `Command '${command}'`;
                    reject(new Error(`${errorPrefix} failed: ${stderr || stdout}`));
                }
            });
            child.on('error', (error) => {
                reject(new Error(`Failed to spawn ${command}: ${error.message}`));
            });
        });
    }
}
exports.UvPackager = UvPackager;
