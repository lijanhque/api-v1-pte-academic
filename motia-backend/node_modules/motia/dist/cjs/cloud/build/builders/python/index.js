"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythonBuilder = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const activate_python_env_1 = require("../../../../utils/activate-python-env");
const constants_1 = require("../../../new-deployment/constants");
const archiver_1 = require("../archiver");
const include_static_files_1 = require("../include-static-files");
const extract_python_data_1 = require("./python-data/extract-python-data");
const read_requirements_1 = require("./python-data/read-requirements");
const resolve_dep_names_1 = require("./python-data/resolve-dep-names");
const uv_packager_1 = require("./uv-packager");
class PythonBuilder {
    constructor(builder, listener) {
        this.builder = builder;
        this.listener = listener;
        (0, activate_python_env_1.activatePythonVenv)({ baseDir: this.builder.projectDir });
        this.packager = new uv_packager_1.UvPackager();
    }
    async buildApiSteps(steps) {
        const zipName = 'router-python.zip';
        const archive = new archiver_1.Archiver(path_1.default.join(constants_1.distDir, zipName));
        const bundleDir = path_1.default.join(constants_1.distDir, 'python', 'router');
        try {
            fs_1.default.mkdirSync(bundleDir, { recursive: true });
            const routerTemplate = this.createRouterTemplate(steps);
            archive.append(routerTemplate, 'router.py');
            await this.generatePackage(bundleDir, 'router.py', archive, routerTemplate);
            (0, include_static_files_1.includeStaticFiles)(steps, this.builder, archive);
            const { compressedSize, uncompressedSize } = await archive.finalize();
            return { compressedSize, uncompressedSize, path: zipName };
        }
        catch (error) {
            throw new Error(`Failed to build Python API router: ${error}`);
        }
        finally {
            this.cleanup(bundleDir);
        }
    }
    async build(step) {
        const entrypointPath = step.filePath.replace(this.builder.projectDir, '');
        const bundlePath = path_1.default.join('python', entrypointPath.replace(/(.*)\.py$/, '$1.zip'));
        const bundleDir = path_1.default.join(constants_1.distDir, 'python', entrypointPath.replace(/(.*)\.py$/, '$1'));
        const outfile = path_1.default.join(constants_1.distDir, bundlePath);
        this.builder.registerStep({ entrypointPath, bundlePath, step, type: 'python' });
        this.listener.onBuildStart(step);
        try {
            fs_1.default.mkdirSync(path_1.default.dirname(outfile), { recursive: true });
            fs_1.default.mkdirSync(bundleDir, { recursive: true });
            const archive = new archiver_1.Archiver(outfile);
            await this.generatePackage(bundleDir, entrypointPath, archive);
            // Include static files
            (0, include_static_files_1.includeStaticFiles)([step], this.builder, archive);
            const { compressedSize, uncompressedSize } = await archive.finalize();
            this.builder.recordStepSize(step, compressedSize, uncompressedSize);
            this.listener.onBuildEnd(step, compressedSize);
        }
        catch (err) {
            this.listener.onBuildError(step, err);
            throw err;
        }
        finally {
            this.cleanup(bundleDir);
        }
    }
    async generatePackage(bundleDir, entrypointPath, archive, fileContent) {
        const requirementsFile = path_1.default.join(this.builder.projectDir, 'requirements.txt');
        const requirements = (0, read_requirements_1.readRequirements)(requirementsFile);
        const sitePackagesPath = (0, activate_python_env_1.getSitePackagesPath)({ baseDir: this.builder.projectDir });
        const dependenciesMap = (0, resolve_dep_names_1.resolveDepNames)(Object.keys(requirements), sitePackagesPath);
        const { externalDependencies, files } = (0, extract_python_data_1.extractPythonData)(this.builder.projectDir, entrypointPath, dependenciesMap, fileContent);
        // move files
        for (const file of files) {
            fs_1.default.mkdirSync(path_1.default.dirname(path_1.default.join(bundleDir, file)), { recursive: true });
            if (fileContent && file === entrypointPath) {
                fs_1.default.writeFileSync(path_1.default.join(bundleDir, file), fileContent);
            }
            else {
                fs_1.default.copyFileSync(path_1.default.join(this.builder.projectDir, file), path_1.default.join(bundleDir, file));
            }
        }
        const dependencies = Object.values(externalDependencies);
        if (dependencies.length > 0) {
            // create requirements.txt
            const requirementsContent = Object.values(externalDependencies)
                .map((dependency) => requirements[dependency])
                .join('\n');
            fs_1.default.writeFileSync(path_1.default.join(bundleDir, 'requirements.txt'), requirementsContent);
            await this.packager.packageDependencies(bundleDir);
        }
        // zip entire folder
        archive.appendDirectory(bundleDir, '/');
    }
    cleanup(bundleDir) {
        if (bundleDir && fs_1.default.existsSync(bundleDir)) {
            try {
                fs_1.default.rmSync(bundleDir, { recursive: true, force: true });
            }
            catch (_error) {
                // Ignore cleanup errors
            }
        }
    }
    createRouterTemplate(steps) {
        const imports = steps
            .map((step, index) => `from ${this.getModuleName(step)} import handler as route${index}_handler, config as route${index}_config`)
            .join('\n');
        const routerPaths = steps
            .map((step, index) => {
            const method = step.config.method.toUpperCase();
            const path = step.config.path;
            return `    '${method} ${path}': RouterPath('${step.config.name}', '${step.config.method.toLowerCase()}', route${index}_handler, route${index}_config)`;
        })
            .join(',\n');
        return fs_1.default
            .readFileSync(path_1.default.join(__dirname, 'router_template.py'), 'utf-8')
            .replace('# {{imports}}', imports)
            .replace('    # {{router paths}}', routerPaths);
    }
    getModuleName(step) {
        // return step path
        return step.filePath.replace(this.builder.projectDir, '').substring(1).replace(/\.py$/, '').replace(/[\\/]/g, '.');
    }
}
exports.PythonBuilder = PythonBuilder;
