"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Archiver = void 0;
const archiver_1 = __importDefault(require("archiver"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
class Archiver {
    constructor(filePath) {
        this.uncompressedSize = 0;
        this.archive = (0, archiver_1.default)('zip', { zlib: { level: 9 } });
        this.outputStream = fs_1.default.createWriteStream(filePath);
        this.archive.pipe(this.outputStream);
    }
    appendDirectory(sourcePath, targetPath) {
        try {
            const stat = fs_1.default.statSync(sourcePath);
            if (!stat.isDirectory()) {
                return;
            }
            this.uncompressedSize += this.calculateDirectorySize(sourcePath);
            this.archive.directory(sourcePath, targetPath === '/' ? false : targetPath);
        }
        catch (_error) { }
    }
    calculateDirectorySize(dirPath) {
        let totalSize = 0;
        try {
            const items = fs_1.default.readdirSync(dirPath);
            for (const item of items) {
                const fullPath = path_1.default.join(dirPath, item);
                try {
                    const stat = fs_1.default.statSync(fullPath);
                    if (stat.isDirectory()) {
                        totalSize += this.calculateDirectorySize(fullPath);
                    }
                    else {
                        totalSize += stat.size;
                    }
                }
                catch (_error) { }
            }
        }
        catch (_error) { }
        return totalSize;
    }
    append(stream, filePath) {
        if (typeof stream === 'string') {
            this.uncompressedSize += Buffer.byteLength(stream, 'utf8');
            this.archive.append(stream, { name: filePath });
        }
        else if (Buffer.isBuffer(stream)) {
            this.uncompressedSize += stream.length;
            this.archive.append(stream, { name: filePath });
        }
        else {
            const stats = fs_1.default.statSync(stream.path);
            this.uncompressedSize += stats.size;
            this.archive.append(stream, { name: filePath });
        }
    }
    async finalize() {
        return new Promise((resolve, reject) => {
            this.outputStream.on('close', () => {
                resolve({
                    compressedSize: this.archive.pointer(),
                    uncompressedSize: this.uncompressedSize,
                });
            });
            this.outputStream.on('error', reject);
            this.archive.finalize();
        });
    }
}
exports.Archiver = Archiver;
