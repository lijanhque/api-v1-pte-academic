"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependenciesFromFile = void 0;
const antlr4ts_1 = require("antlr4ts");
const python_ast_1 = require("python-ast");
const Python3Lexer_1 = require("python-ast/dist/parser/Python3Lexer");
const Python3Parser_1 = require("python-ast/dist/parser/Python3Parser");
const constants_1 = require("./constants");
const python_errors_1 = require("./python-errors");
function parse(source, sourceName) {
    const chars = antlr4ts_1.CharStreams.fromString(source, sourceName);
    const lexer = new Python3Lexer_1.Python3Lexer(chars);
    const tokens = new antlr4ts_1.CommonTokenStream(lexer);
    const parser = new Python3Parser_1.Python3Parser(tokens);
    // Remove default console error listeners
    parser.removeErrorListeners();
    const listener = {
        syntaxError: (_recognizer, _offendingSymbol, line, charPositionInLine, msg) => {
            throw new python_errors_1.PythonCompilationError(sourceName, `${msg} at line ${line}:${charPositionInLine}`);
        },
    };
    // Add your custom one
    parser.addErrorListener(listener);
    return parser.file_input();
}
const getDependenciesFromFile = (content, path, externalDependenciesMap) => {
    const result = parse(content + '\n', path);
    const modulesSet = new Set();
    (0, python_ast_1.createVisitor)({
        visitImport_from: (ctx) => {
            const name = ctx.dotted_name();
            if (name) {
                let dots = ctx
                    .DOT()
                    .map((dot) => dot.text)
                    .join('');
                const dotsText = ctx.getChild(1)?.text ?? '';
                // when ...package the parser doesn't return as ctx.DOT() â€” we need to handle it manually
                if (!dots && dotsText[0] === '.') {
                    dots = dotsText;
                }
                modulesSet.add(dots.concat(name.text));
            }
        },
        visitImport_name: (ctx) => {
            const names = ctx.dotted_as_names();
            modulesSet.add(names.dotted_as_name(0)?.getChild(0)?.text ?? names.text);
        },
    }).visit(result);
    const dependencies = {
        standardLibDependencies: new Set(),
        externalDependencies: new Set(),
        projectDependencies: new Set(),
    };
    for (const module of modulesSet) {
        const [moduleName] = module.split('.');
        if (module[0] === '.') {
            dependencies.projectDependencies.add(module);
        }
        else if (constants_1.STANDARD_LIB_MODULES.has(module)) {
            dependencies.standardLibDependencies.add(module);
        }
        else if (externalDependenciesMap[module] || externalDependenciesMap[moduleName]) {
            dependencies.externalDependencies.add(module);
        }
        else {
            dependencies.projectDependencies.add(module);
        }
    }
    return dependencies;
};
exports.getDependenciesFromFile = getDependenciesFromFile;
