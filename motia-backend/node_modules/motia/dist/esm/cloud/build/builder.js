export class Builder {
    constructor(projectDir, listener) {
        this.projectDir = projectDir;
        this.listener = listener;
        this.stepCompressedSizes = new Map();
        this.stepUncompressedSizes = new Map();
        this.routerCompressedSizes = new Map();
        this.routerUncompressedSizes = new Map();
        this.modulegraphInstalled = false;
        this.builders = new Map();
        this.stepsConfig = {};
        this.streamsConfig = {};
        this.routersConfig = {};
    }
    registerBuilder(type, builder) {
        this.builders.set(type, builder);
    }
    registerStateStream(stream) {
        this.listener.onStreamCreated(stream);
        this.streamsConfig[stream.config.name] = {
            name: stream.config.name,
            storageType: stream.config.baseConfig.storageType,
        };
    }
    registerStep(args) {
        this.stepsConfig[args.bundlePath] = {
            type: args.type,
            entrypointPath: args.entrypointPath,
            config: args.step.config,
            filePath: args.step.filePath,
        };
    }
    recordStepSize(step, compressedSize, uncompressedSize) {
        this.stepCompressedSizes.set(step.filePath, compressedSize);
        this.stepUncompressedSizes.set(step.filePath, uncompressedSize);
    }
    async buildStep(step) {
        const type = this.determineStepType(step);
        const builder = this.builders.get(type);
        if (!builder) {
            this.listener.onBuildSkip(step, `No builder found for type: ${type}`);
            return;
        }
        try {
            await builder.build(step);
        }
        catch (err) {
            this.listener.onBuildError(step, err);
            throw err;
        }
    }
    async buildApiSteps(steps) {
        const nodeSteps = steps.filter((step) => this.determineStepType(step) === 'node');
        const pythonSteps = steps.filter((step) => this.determineStepType(step) === 'python');
        const nodeBuilder = this.builders.get('node');
        const pythonBuilder = this.builders.get('python');
        this.routersConfig = {};
        if (nodeSteps.length > 0 && nodeBuilder) {
            this.listener.onApiRouterBuilding('node');
            const { compressedSize, uncompressedSize, path } = await nodeBuilder.buildApiSteps(nodeSteps);
            this.listener.onApiRouterBuilt('node', compressedSize);
            this.routersConfig.node = path;
            this.routerCompressedSizes.set('node', compressedSize);
            this.routerUncompressedSizes.set('node', uncompressedSize);
        }
        if (pythonSteps.length > 0 && pythonBuilder) {
            this.listener.onApiRouterBuilding('python');
            const { compressedSize, uncompressedSize, path } = await pythonBuilder.buildApiSteps(pythonSteps);
            this.listener.onApiRouterBuilt('python', compressedSize);
            this.routersConfig.python = path;
            this.routerCompressedSizes.set('python', compressedSize);
            this.routerUncompressedSizes.set('python', uncompressedSize);
        }
    }
    determineStepType(step) {
        if (step.config.type === 'noop') {
            return 'noop';
        }
        else if (step.filePath.endsWith('.ts') || step.filePath.endsWith('.js')) {
            return 'node';
        }
        else if (step.filePath.endsWith('.py')) {
            return 'python';
        }
        else if (step.filePath.endsWith('.rb')) {
            return 'ruby';
        }
        return 'unknown';
    }
}
